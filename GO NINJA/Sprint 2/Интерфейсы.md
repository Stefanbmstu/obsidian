_Интерфейс_ в Go — это набор сигнатур методов (то есть список методов без реализации). Можно воспринимать как контракт по которому есть требования и поставщик (структура) должна их реализовывать.
Интерфейсное значение внутри хранит информацию о конкретном (неинтерфейсном) типе и его значении
```
                                            ConcreteType         ConcreteType
                                           /                            /
interfaceValue = nil       interfaceValue              interfaceValue
                                           \                            \
                                            nil                  Concrete value
```

Интерфейс геометрической фигуры:

```go
type geometry interface {
    area() float64
    perim() float64
}
```

Реализуем интерфейс в типе «прямоугольник». Реализовать интерфейс = реализовать его методы. Действует «утиный» принцип, как в питоне: если у типа есть перечисленные в интерфейсе методы — значит, он реализовал интерфейс. Явно указывать, что `rect` реализует `geometry`, не требуется:

```go
type rect struct {
    width, height float64
}

func (r rect) area() float64 {
    return r.width * r.height
}

func (r rect) perim() float64 {
    return 2*r.width + 2*r.height
}
```

Аналогично для типа «круг»:

```go
type circle struct {
    radius float64
}

func (c circle) area() float64 {
    return math.Pi * c.radius * c.radius
}

func (c circle) perim() float64 {
    return 2 * math.Pi * c.radius
}
```

Если у переменной интерфейсный тип, она поддерживает все методы, заданные на интерфейсе. Благодаря этому функция `measure()` работает с любой фигурой, реализующей интерфейс `geometry`:

```go
func measure(g geometry) {
    fmt.Printf("%T: %+v\\n", g, g)
    fmt.Println("area:", g.area())
    fmt.Println("perimiter:", g.perim())
}
```

Раз типы `circle` и `rect` реализуют интерфейс `geometry`, мы можем передать их экземпляры в функцию `measure()`:

```go
r := rect{width: 3, height: 4}
c := circle{radius: 5}

measure(r)
// main.rect: {width:3 height:4}
// area: 12
// perimiter: 14

measure(c)
// main.circle: {radius:5}
// area: 78.53981633974483
// perimiter: 31.41592653589793
```

[песочница](https://go.dev/play/p/bgOHM6Q3_Li)

### **Встраивание интерфейса**

Иногда при композиции хочется дать доступ к поведению, но скрыть структуру. В этом поможет _встраивание интерфейса_ (interface embedding).

Есть тип «счетчик»:

```go
type counter struct {
    val uint
}
func (c *counter) increment() {
    c.val++
}
func (c *counter) value() uint {
    return c.val
}
```

Мы хотим встраивать счетчик в другие типы, но не давать прямой доступ к полю `val` — чтобы менять значение счетчика можно было только через методы.

Определим интерфейс счетчика:

```go
type Counter interface {
    increment()
    value() uint
}
```

И вместо конкретного типа `counter` встроим интерфейс `Counter`, который он реализует:

```go
type usage struct {
    service string
    Counter
}
```

В конструкторе будем создавать конкретное значение типа `counter`, но потребителям об этом знать не обязательно:

```go
func newUsage(service string) *usage {
    return &usage{service, &counter{}}
}
```

Поскольку мы встроили интерфейс, прямого доступа к `counter.val` больше нет. Можно использовать только методы интерфейса:

```go
usage := newUsage("find")
usage.increment()
usage.increment()
usage.increment()
fmt.Printf("%s usage: %d\\n", usage.service, usage.value())
// find usage: 3
```

[песочница](https://go.dev/play/p/ZGBZWZJ_MVm)

### **Пустой интерфейс**

Если у интерфейса нет методов, его называют _пустым_ (empty):

```go
interface{}
```

Пустой интерфейс может содержать значение любого типа (ведь у каждого типа есть как минимум 0 методов). Пустые интерфейсы используют, если тип значения заранее не известен. Например, функция из пакета `fmt`:

```go
func Println(a ...interface{}) (n int, err error)
```

`fmt.Println()` умеет печатать что угодно, поэтому принимает значения типа `interface{}`.

Начиная с Go 1.18 для `interface{}` ввели псевдоним `any`. Разницы между ними нет (псевдоним — это буквально тот же самый тип), но многие теперь предпочитают `any` за его краткость и выразительность.

```go
func repr(val any) string {
    return fmt.Sprintf("%#v", val)
}

func main() {
    var num int = 42
    fmt.Println(repr(num))
    // 42

    var thing interface{} = "shy string"
    fmt.Println(repr(thing))
    // "shy string"
}
```

[песочница](https://go.dev/play/p/-jx-g7HUdUP)

### **Приведение типа**

_Приведение типа_ (type assertion) извлекает конкретное значение из переменной интерфейсного типа:

```go
var value any = "hello"
str := value.(string)
fmt.Println(str)
// hello
```

Если тип конкретного значения отличается от указанного, произойдет ошибка:

```go
flo := value.(float64)
// ошибка
```

Чтобы проверить тип конкретного значения, используют опциональный флаг, который сигнализирует — правильный тип или нет:

```go
str, ok := value.(string)
fmt.Println(str, ok)
// hello true

flo, ok := value.(float64)
fmt.Println(flo, ok)
// 0 false
```

### **Переключатель типа**

Приведение типа можно использовать вместе со `switch`. Такая конструкция называется _переключателем типа_ (type switch):

```go
var value any = "hello"

switch v := value.(type) {
case string:
    fmt.Printf("%#v is a string\\n", v)
case float64:
    fmt.Printf("%#v is a float\\n", v)
default:
    fmt.Printf("%#v is a mystery\\n", v)
}
// "hello" is a string
```

`v` внутри сработавшей ветки переключателя имеет конкретный тип вместо `any` (в примере — `string`).

[песочница](https://go.dev/play/p/kEq0UXg2KrE)

### **Интерфейсы и nil**

Внутри Go переменная типа `interface` представлена как пара `(type, value)`, где value — конкретное значение, а type — тип этого значения. Например:

```go
// переменная интерфейсного типа
var ivar interface{}

ivar = "hello"
// ivar представлена парой (string, "hello")

ivar = 3.14
// ival представлена парой (float64, 3.14)
```

Когда мы вызываем метод на интерфейсной переменной, Go вызывает соответствующий метод `value`:

```go
type greeter interface {
    greet()
}

type english struct {
    name string
}
func (e *english) greet() {
    fmt.Println("Hello", e.name)
}

var ivar greeter = &english{"world"}
// type == *english, value == &english{"world"}
ivar.greet()
// вызывает value.greet() и печатает "Hello world"
```

Пока интерфейсной переменной не присвоено значение, у нее и `type`, и `value` равны `nil`, поэтому сама переменная считается равной `nil`:

```go
var ivar any
// type == nil, value == nil
// поэтому ivar == nil
fmt.Println(ivar == nil)
// true
```

Но как только интерфейсной переменной присвоили значение, `type` перестает быть `nil`. Поэтому переменная больше не равна `nil`, даже если `value` равно `nil`:

```go
var e *english
fmt.Println(e == nil)
// true

ivar = e
// type == *english, value == nil
// поскольку type != nil, то ivar != nil
fmt.Println(ivar == nil)
// false
```

Пока интерфейсная переменная равна `nil`, вызвать метод на ней не получится (ведь `type` неизвестен):

```go
var ivar greeter
ivar.greet()
// panic: runtime error: invalid memory address or nil pointer dereference
```

Но когда тип известен — вызвать метод на интерфейсной переменной можно, даже если `value` равно `nil`. Поэтому в методах стоит учитывать, что получатель может быть `nil`:

```go
type greeter interface {
    greet()
}

type english struct {
    name string
}

// e может быть nil!
func (e *english) greet() {
    if e == nil {
        fmt.Println("I'm nil :(")
        return
    }
    fmt.Println("Hello", e.name)
}

var ivar greeter
ivar = (*english)(nil)
ivar.greet()
// I'm nil :(
```

Это контринтуитивная штука, поэтому ее имеет смысл запомнить.

[песочница](https://go.dev/play/p/l0AayMUNPfO)

### **Дополнительное чтение**

[Interfaces](https://go.dev/ref/spec#Interface_types)

[Type assertions](https://go.dev/ref/spec#Type_assertions)

[Interfaces and other types](https://go.dev/doc/effective_go#interfaces_and_types)

[Embedding](https://go.dev/doc/effective_go#embedding)