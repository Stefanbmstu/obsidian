_Структура_ (struct) группирует поля в единую запись. В Go нет классов и объектов, так что структура — наиболее близкий аналог объекта в питоне и js.

Объявим тип `person` на основе структуры с полями `name` и `age`:

```go
type person struct {
    name string
    age  int
}
```

Так создается новая структура типа `person`:

```go
bob := person{"Bob", 20}
fmt.Println(bob)
// {Bob 20}
```

Можно явно указать названия полей:

```go
alice := person{name: "Alice", age: 30}
fmt.Println(alice)
// {Alice 30}
```

Если не указать поле, оно получит нулевое значение:

```go
fred := person{name: "Fred"}
fmt.Println(fred)
// {Fred 0}
```

Оператор `&` возвращает указатель на структуру:

```go
annptr := &person{name: "Ann", age: 40}
fmt.Println(annptr)
// &{Ann 40}
```

В Go иногда создают новые структуры через функцию-конструктор с префиксом `new`:

```go
func newPerson(name string) *person {
    p := person{name: name}
    p.age = 42
    return &p
}
```

Функция возвращает указатель на локальную переменную — это нормально. Go распознает такие ситуации, и выделяет память под структуру в куче (heap) вместо стека (stack), так что структура продолжит существовать после выхода из функции.

```
john := newPerson("John")
fmt.Println(john)
// &{John 42}
```

Если функция-конструктор возвращает саму структуру, а не указатель — удобно использовать префикс `make` вместо `new`:

```go
func makePerson(name string) person {
    p := person{name: name}
    p.age = 42
    return p
}
```

> В реальности чаще не заморачиваются и всегда используют префикс new вне зависимости от того, что возвращает конструктор — значение или указатель на него. Но на курсе я буду соблюдать это разделение: make — значение, new — указатель.

Доступ к полям структуры — через точку:

```go
sean := person{name: "Sean", age: 50}
fmt.Println(sean.name)
// Sean
```

Чтобы получить доступ к полям структуры через указатель, не обязательно разыменовывать его через `*`. Эти два варианта эквивалентны:

```go
sven := &person{name: "Sven", age: 50}
fmt.Println((*sven).age)
// 50
fmt.Println(sven.age)
// 50
```

Поля структуры можно изменять:

```go
sven.age = 51
fmt.Println(sven.age)
// 51
```

[песочница](https://go.dev/play/p/j99vztQHYg2)

### **Составные структуры**

Структуры могут включать другие структуры:

```go
type person struct {
    firstName string
    lastName  string
}

type book struct {
    title  string
    author person
}
```

```go
b := book{
    title: "The Majik Gopher",
    author: person{
        firstName: "Christopher",
        lastName:  "Swanson",
    },
}
fmt.Println(b)
// {The Majik Gopher {Christopher Swanson}}
```

Если вложенная структура не представляет самостоятельной ценности, можно даже не объявлять отдельный тип:

```go
type user struct {
    name  string
    karma struct {
        value int
        title string
    }
}
```

```go
u := user{
    name: "Chris",
    karma: struct {
        value int
        title string
    }{
        value: 100,
        title: "^-^",
    },
}
fmt.Printf("%+v\\n", u)
// {name:Chris karma:{value:100 title:^-^}}
```

Благодаря шаблону `%+v`, `Printf()` печатает структуру вместе с названиями полей.

Поле структуры может ссылаться на другую структуру:

```go
type comment struct {
    text   string
    author *user
}
```

```go
chris := user{
    name: "Chris",
}
c := comment{
    text:   "Gophers are awesome!",
    author: &chris,
}
fmt.Printf("%+v\\n", c)
// {text:Gophers are awesome! author:0xc0000981e0}
```

[песочница](https://go.dev/play/p/w91APw8y4O2)

### **Методы**

Go позволяет определять _методы_ на типах.

Метод отличается от обычной функции специальным параметром — _получателем_. В определении метода получатель указывается сразу после ключевого слова `func`. В данном случае — получатель типа `rect`:

```go
type rect struct {
    width, height int
}

func (r rect) area() int {
    return r.width * r.height
}
```

Метод вызывается для получателя через точку, как в питоне или js:

```go
r := rect{width: 10, height: 5}
fmt.Println("rect area:", r.area())
// rect area: 50
```

Получателем может быть не значение заданного типа, а указатель на это значение:

```go
type circle struct {
    radius int
}

func (c *circle) area() float64 {
    return math.Pi * math.Pow(float64(c.radius), 2)
}
```

```go
cptr := &circle{radius: 5}
fmt.Println("circle area:", cptr.area())
// circle area: 78.54
```

При вызове метода Go автоматически преобразует значение получателя в указатель или указатель в значение, как того требует определение метода. Любой из перечисленных вариантов будет работать:

```go
rptr := &r
r.area()
rptr.area()

c := *cptr
c.area()
cptr.area()
```

Считается хорошим тоном во всех методах использовать или только значение, или только указатель, но не смешивать одно с другим. Обычно используют указатель: так Go не приходится копировать всю структуру, а метод может ее изменить.

```go
// Если метод принимает получателя как значение, изменить его не получится
func (r rect) scale(factor int) {
    r.width *= factor
    r.height *= factor
}

fmt.Println("rect before scaling:", r)
// rect before scaling: {10 5}

r.scale(2)

fmt.Println("rect after scaling:", r)
// rect after scaling: {10 5}
```

```go
// Если метод принимает получателя как указатель, его можно изменить
func (c *circle) scale(factor int) {
    c.radius *= factor
}

fmt.Println("circle before scaling:", c)
// circle before scaling: {5}

c.scale(2)

fmt.Println("circle after scaling:", c)
// circle after scaling: {10}

```

Вопрос «значение или указатель для получателя» так популярен, что у сообщества есть [отдельный гайдлайн](https://go.dev/wiki/CodeReviewComments#receiver-type) на эту тему.

[песочница](https://go.dev/play/p/IHQozTj86Wf)

### **Определяемые типы**

На предыдущем шаге мы создали структурный тип и методы для него. Но новый тип не обязательно создавать на основе структуры — можно использовать любые базовые типы.

Создадим тип «ИНН» на основе строки:

```go
type inn string
```

Тип `inn` (он называется _определяемым типом_, defined type) получил свойства базового типа `string`. Добавим ему новое поведение с помощью метода:

```go
func (id inn) isValid() bool {
    if len(id) != 12 {
        return false
    }
    for _, char := range id {
        if !unicode.IsDigit(char) {
            return false
        }
    }
    return true
}
```

```go
inn1 := inn("111201284667")
fmt.Println("inn", inn1, "is valid:", inn1.isValid())
// inn 111201284667 is valid: true

inn2 := inn("ohmyinn12345")
fmt.Println("inn", inn2, "is valid:", inn2.isValid())
// inn ohmyinn12345 is valid: false

```

Это чем-то похоже на наследование, но механизм более примитивный. Если создать новый определяемый тип на основе `inn` — он унаследует структуру и свойства `inn`, но не методы:

```go
type otherid inn
```

```go
other := otherid("111201284667")
fmt.Println("other inn", other, "is valid:", other.isValid())
// ОШИБКА: other.isValid undefined
```

[песочница](https://go.dev/play/p/qHqsPg9JHj6)

### **Композиция**

В Go нет наследования. Вместо него активно используется композиция — когда новое поведение собирают из кирпичиков существующего.

Есть тип «счетчик»:

```go
type counter struct {
    value uint
}
```

Его можно увеличивать на единицу:

```go
func (c *counter) increment() {
    c.value++
}
```

Или на указанное число:

```go
func (c *counter) incrementDelta(delta uint) {
    c.value += delta
}
```

Мы хотим замерять использование сервисов. Чтобы не дублировать существующие функции, добавим счетчик в тип «использование сервиса»:

```go
type usage struct {
    service string
    counter counter
}

func makeUsage(service string) usage {
    return usage{service, counter{}}
}
```

Будем мерить использование сервиса, увеличивая его счетчик:

```go
usage := makeUsage("find")
usage.counter.increment()
usage.counter.increment()
usage.counter.increment()
fmt.Printf("%s usage: %d\\n", usage.service, usage.counter.value)
// find usage: 3
```

Для типа «просмотры страницы» тоже добавим счетчик:

```go
type pageviews struct {
    url *url.URL
    counter counter
}

func makePageviews(uri string) pageviews {
    u, err := url.Parse(uri)
    if err != nil {
        log.Fatal(err)
    }
    return pageviews{u, counter{}}
}
```

И будем мерить просмотры:

```go
pv := makePageviews("/doc/find")
pv.counter.incrementDelta(100)
fmt.Printf("%s views: %d\\n", pv.url, pv.counter.value)
// /doc/find views: 100
```

[песочница](https://go.dev/play/p/kgFKZlGFRTJ)

### **Встраивание**

Все хорошо, но несколько неудобно было писать `usage.counter.increment()` на предыдущем шаге. По-хорошему, `usage`  _расширяет_ `counter` — отношение между ними больше похоже на наследование, чем на композицию. В Go в таких случаях используют _встраивание_ (embedding). Посмотрим, как оно работает.

Есть тип «счетчик», такой же, как на предыдущем шаге:

```go
type counter struct {
    value uint
}
func (c *counter) increment() {
    c.value++
}
func (c *counter) incrementDelta(delta uint) {
    c.value += delta
}
```

Мы хотим замерять использование сервисов. _Встроим_ счетчик в тип «использование сервиса»:

```go
type usage struct {
    service string
    counter
}

func makeUsage(service string) usage {
    return usage{service, counter{}}
}
```

Благодаря встраиванию, поля и методы счетчика доступны прямо на `usage`, без обращения к полю `counter`:

```go
usage := makeUsage("find")
usage.increment()
usage.increment()
usage.increment()
fmt.Printf("%s usage: %d\\n", usage.service, usage.value)
// find usage: 3
```

Аналогично с типом «просмотры страниц»:

```go
type pageviews struct {
    url *url.URL
    counter
}

func makePageviews(uri string) pageviews {
    u, err := url.Parse(uri)
    if err != nil {
        log.Fatal(err)
    }
    return pageviews{u, counter{}}
}
```

Поля и методы счетчика доступны прямо на `pageviews`:

```go
pv := makePageviews("/doc/find")
pv.incrementDelta(100)
fmt.Printf("%s views: %d\\n", pv.url, pv.value)
// /doc/find views: 100
```

[песочница](https://go.dev/play/p/E_7DlwchsjN)

Есть тип «счетчик»:

```go
type counter struct {
    value uint
}

func (c *counter) increment() {
    c.value++
}
```

Можно создать значение `c` типа `counter` и вызвать метод `c.increment`:

```go
c := new(counter)

c.increment()
c.increment()
c.increment()

fmt.Println(c.value)
// 3
```

А можно вызвать метод `c.increment` как функцию:

```go
c := new(counter)
inc := c.increment

inc()
inc()
inc()

fmt.Println(c.value)
// 3
```

Здесь функция `inc` работает как замыкание — она имеет доступ к внутренним полям `c`, хотя снаружи они не видны.

Такая штука называется _метод-значение_ (method value). Используется редко. Но может пригодиться, чтобы разрешить клиенту вызывать метод структуры, не давая при этом доступ к ее полям.

[песочница](https://go.dev/play/p/TX2ZEucLYMx)

### **Метод-выражение**

Можно сделать еще более причудливый финт. Использовать метод вообще без привязки к конкретному значению, как обычную функцию:

```go
inc := (*counter).increment

first := new(counter)
inc(first)
inc(first)
inc(first)

second := new(counter)
inc(second)

fmt.Println(first.value)
// 3
fmt.Println(second.value)
// 1
```

Здесь функция `inc` принимает первым аргументом получателя метода — значение `x` типа `*counter` — и дальше работает как метод, увеличивая значение `x.value`.

Такая штука называется _метод-выражение_ (method expression). На практике встречается еще реже, чем метод-значение.

[песочница](https://go.dev/play/p/s8tstQne3lV)

### **Дополнительное чтение**

[Struct](https://go.dev/ref/spec#Struct_types)

[Properties of types and values](https://go.dev/ref/spec#Properties_of_types_and_values) • [type declarations](https://go.dev/ref/spec#Type_declarations) • [conversions](https://go.dev/ref/spec#Conversions)

[Method declarations](https://go.dev/ref/spec#Method_declarations) • [method expressions](https://go.dev/ref/spec#Method_expressions) • [method values](https://go.dev/ref/spec#Method_values)

[Pointers vs. Values](https://go.dev/doc/effective_go#pointers_vs_values)