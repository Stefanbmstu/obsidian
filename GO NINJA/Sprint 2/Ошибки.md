В Go нет исключений и блока try-catch, как в питоне или js. Вместо этого функции явно возвращают ошибку отдельным значением. Благодаря этому ошибки невозможно проигнорировать, а разработчики продумывают поведение программы в случае проблем.

Ошибки принято возвращать последним значением с интерфейсным типом `error`:

```go
func sqrt(x float64) (float64, error) {
    if x < 0 {
        return 0, errors.New("expect x >= 0")
    }
    // `nil` в качестве ошибки указывает, что ошибок не было.
    return math.Sqrt(x), nil
}
```

Проверим работу `sqrt()` на положительном и отрицательном значениях. Обратите внимание, как мы получаем результат и проверяем ошибку внутри условия `if` — это стандартная практика в Go.

```go
for _, x := range []float64{49, -49} {
    if res, err := sqrt(x); err != nil {
        fmt.Printf("sqrt(%v) failed: %v\\n", x, err)
    } else {
        fmt.Printf("sqrt(%v) = %v\\n", x, res)
    }
}
// sqrt(49) = 7
// sqrt(-49) failed: expect x >= 0
```

[песочница](https://go.dev/play/p/ai4OtMECoDO)

### **Собственный тип ошибки**

Чтобы создать собственный тип ошибки, достаточно реализовать метод `Error()`.

```go
// фрагмент кода стандартной библиотеки
type error interface {
    Error() string
}
```

Создадим ошибку, которая описывает проблему поиска `substr` в строке `src`:

```go
type lookupError struct {
    src    string
    substr string
}

func (e lookupError) Error() string {
    return fmt.Sprintf("'%s' not found in '%s'", e.substr, e.src)
}
```

Напишем функцию `indexOf()`, которая возвращает индекс вхождения подстроки `substr` в строку `src`. Если вхождения нет, возвращает ошибку типа `lookupError`:

```go
func indexOf(src string, substr string) (int, error) {
    idx := strings.Index(src, substr)
    if idx == -1 {
        // Создаем и возвращаем ошибку типа `lookupError`.
        return -1, lookupError{src, substr}
    }
    return idx, nil
}
```

Проверим работу `indexOf()` для разных подстрок.

```go
src := "go is awesome"
for _, substr := range []string{"go", "js"} {
    if res, err := indexOf(src, substr); err != nil {
        fmt.Printf("indexOf(%#v, %#v) failed: %v\\n", src, substr, err)
    } else {
        fmt.Printf("indexOf(%#v, %#v) = %v\\n", src, substr, res)
    }
}
// indexOf("go is awesome", "go") = 0
// indexOf("go is awesome", "js") failed: 'js' not found in 'go is awesome'
```

Поскольку `indexOf()` возвращает общий тип `error`, чтобы получить доступ к конкретному объекту ошибки, придется использовать приведение типа:

```go
_, err := indexOf(src, "js")
if err, ok := err.(lookupError); ok {
    fmt.Println("err.src:", err.src)
    fmt.Println("err.substr:", err.substr)
}
// err.src: go is awesome
// err.substr: js
```

[песочница](https://go.dev/play/p/BoQblqUhep8)

### **Defer**

_Defer_ позволяет отложить выполнение кода до момента завершения функции. Обычно его используют, чтобы освободить ресурсы, выделенные внутри функции (открытые файлы, соединения и тому подобное). В питоне в таких случаях применяют контекстные менеджеры, а в js конструкцию try-finally.

Допустим, мы хотим создать файл, записать в него что-то и закрыть. Вот как поможет `defer`:

```go
func main() {
    f, err := createFile("/tmp/defer.txt")
    if err != nil {
        fmt.Println("Error creating file:", err)
        return
    }

    defer closeFile(f)    // (1)

    if err := writeFile(f); err != nil {
        fmt.Println("Error writing to file:", err)
        return            // (2)
    }

    fmt.Println("Success!")
}
```

После того как файл открыт, мы с помощью `defer` указываем, что необходимо вызвать отложенную функцию `closeFile()` ➊. Она выполнится в самом конце, при завершении функции `main()`. Причем отложенная функция отработает в любом случае — даже если во время записи в файл произошла ошибка и сработал досрочный `return` ➋.

Допустим, создание файла пройдет успешно, а при записи случится ошибка:

```go
func createFile(name string) (*os.File, error) {
    fmt.Println("Creating file...")
    // ...
}

func writeFile(f *os.File) error {
    fmt.Println("Writing to file...")
    // эмулируем неминуемую ошибку
    return fmt.Errorf("oh no, it all went wrong!")
}

func closeFile(f *os.File) {
    fmt.Println("Closing file...")
    // ...
}
```

`closeFile()` все равно отработает:

```
Creating file...
Writing to file...
Error writing to file: oh no, it all went wrong!
Closing file...

```

[песочница](https://go.dev/play/p/SJU27B-8D3b)

### **Panic**

Если во время выполнения программы происходит неисправимая ошибка, срабатывает _паника_ (panic). Это аналог исключения в питоне или js.

Допустим, мы написали функцию, которая возвращает символ строки по индексу, но забыли проверить, что индекс попадает в границы:

```go
func getChar(str string, idx int) byte {
    return str[idx]
}
```

Если вызвать `getChar()` с некорректным индексом — сработает паника:

```go
c := getChar("hello", 10)
// panic: runtime error: index out of range [10] with length 5
```

Панику можно вызвать и вручную с помощью одноименной встроенной функции:

```go
panic("oops")
```

Так редко делают — в Go принято возвращать ошибку из функции, а не паниковать.

[песочница](https://go.dev/play/p/ni8dgzRPB7V)

### **Recover**

Раз есть непредвиденные ошибки (паника), должен быть и способ их поймать. В Go для этого используется встроенная функция `recover()`. Посмотрим, как она работает.

Мы все так же забыли проверить, что индекс попадает в границы:

```go
func getChar(str string, idx int) byte {
    return str[idx]
}
```

Но зная свою забывчивость, решили отловить любые непредвиденные ошибки:

```go
func protect(fn func()) {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("ERROR:", err)
        } else {
            fmt.Println("Everything went smoothly!")
        }
    }()
    fn()
}
```

`protect()` первым делом объявляет анонимную отложенную функцию, которая сработает после того, как будет выполнена `fn()`. Если срабатывает паника, вызывается отложенная функция. Внутри нее `recover()` возвращает ошибку, которая вызвала панику. Если паники не было, отложенная функция тоже вызывается, но `recover()` внутри возвращает `nil`.

Здесь сработает паника:

```go
protect(func() {
    c := getChar("hello", 10)
    fmt.Println("hello[10] = ", c)
})
// ERROR: runtime error: index out of range [10] with length 5
```

А здесь функция отработает без ошибок:

```go
protect(func() {
    c := getChar("hello", 4)
    fmt.Println("hello[4] =", c)
})
// hello[4] = 111
// Everything went smoothly!
```

Возможно, вы заметили, что ручной вызов `panic()` в сочетании с `defer()` и `recover()` можно использовать, чтобы эмулировать конструкцию try-catch. В Go так не принято. Всегда старайтесь явно возвращать ошибки из функции, а на вызывающей стороне проверять их.

[песочница](https://go.dev/play/p/YP_kCsf4p-K)

### **Обертывание ошибок**

Допустим, есть функция, которая извлекает значение по ключу из карты и возвращает ошибку, если ключ не найден:

```go
var errNotFound error = errors.New("not found")

func getValue(m map[string]string, key string) (string, error) {
    val, ok := m[key]
    if !ok {
        return "", errNotFound
    }
    return val, nil
}
```

И есть тип `languages` с информацией о языках. Он возвращает описание языка по названию:

```go
type languages map[string]string

func (l languages) describe(lang string) (string, error) {
    descr, err := getValue(l, lang)
    if err != nil {
        return "", err
    }
    return descr, nil
}
```

```go
var langs languages = languages{
    "go":     "is awesome",
    "python": "is everywhere",
    "php":    "just is",
}

func main() {
    descr, err := langs.describe("java")
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(descr)
}
```

Внутри у `languages` карта, а метод `languages.describe()` использует `getValue()`, чтобы получить информацию о языке по названию. Получив ошибку, метод транслирует ее клиенту. В примере для `"java"` напечатается такой результат:

```
not found
```

Формально все верно. Но `errNotFound` — низкоуровневая ошибка общего назначения. Она ничего не говорит о проблеме с поиском языка. Клиент хотел бы больше информации.

Можно создать новую ошибку в `describe()` с помощью `fmt.Errorf()`:

```go
func (l languages) describe(lang string) (string, error) {
    descr, err := getValue(l, lang)
    if err != nil {
        return "", fmt.Errorf("error describing %s: unknown language", lang)
    }
    return descr, nil
}
```

```
error describing java: unknown language
```

Но создав новую ошибку, мы потеряли информацию о первоначальной `errNotFound`. Вдруг клиенту она важна?

Можно _обернуть_ (wrap) исходную ошибку в новую с помощью `fmt.Errorf()`  и спецификатора `%w`:

```go
func (l languages) describe(lang string) (string, error) {
    descr, err := getValue(l, lang)
    if err != nil {
        return "", fmt.Errorf("error describing %s: %w", lang, err)
    }
    return descr, nil
}
```

Теперь метод возвращает ошибку-матрешку: снаружи у нее информативная `error describing...`, а внутри исходная `errNotFound`. В сложных программах таких «обертываний» может быть много, пока ошибка поднимается от самых нижних слоев кода к уровню API или UI.

### **Обертывание собственных ошибок**

Если вместо `fmt.Errorf()` мы захотим использовать собственный тип ошибки — дело усложнится. Допустим, хотим записывать в ошибку название языка отдельным полем:

```go
type languageErr struct {
    lang string
}
 
func (le languageErr) Error() string {
    return fmt.Sprintf("%s language error", le.lang)
}
```

Чтобы `languageErr` могла выступать оберткой для других ошибок, придется сделать еще две вещи:

1. Добавить отдельное поле для внутренней ошибки (ее будем оборачивать).
2. Добавить метод `Unwrap()`, который возвращает внутреннюю ошибку («разворачивает»).

```go
type languageErr struct {
    lang string
    err  error
}

func (le languageErr) Error() string {
    return fmt.Sprintf("%s language error: %v", le.lang, le.err)
}

func (le languageErr) Unwrap() error {
    return le.err
}
```

Теперь можно создать новую `languageErr` как обертку над исходной ошибкой в методе `describe()`:

```go
func (l languages) describe(lang string) (string, error) {
    descr, err := getValue(l, lang)
    if err != nil {
        return "", languageErr{lang, err}
    }
    return descr, nil
}
```

Сама по себе слоеная ошибка — только половина дела. Вторая половина — научиться клиенту с ней работать.

### **errors.Is()**

Получив ошибку-матрешку, клиент может проверить, есть ли на каком-то слое интересующая его проблема. Для этого используют функцию `errors.Is()`:

```go
func (l languages) describe(lang string) (string, error) {
    descr, err := getValue(l, lang)
    if err != nil {
        return "", languageErr{lang, err}
    }
    return descr, nil
}

// ...

func main() {
    descr, err := langs.describe("java")
    if errors.Is(err, errNotFound) {
        fmt.Println("this is an errNotFound error")
        // do something about it...
    }
    if err != nil {
        fmt.Println(err)
        return
    }
    fmt.Println(descr)
}

```

```bash
this is an errNotFound error
java language error: not found
```

Неважно, сколько в ошибке слоев. Если на каком-то из них встретилось значение `errNotFound` — `errors.Is()` вернет `true`.

[песочница](https://go.dev/play/p/bX5LaSSHHQa)

### **errors.As()**

Раньше мы использовали приведение типа, чтобы получить доступ к ошибке конкретного типа вместо абстрактного `error`:

```go
descr, err := langs.describe("java")
if langErr, ok := err.(languageErr); ok {
    fmt.Println("Language error:", langErr.lang)
}

```

```
Language error: java
```

Но это работает только для ошибки самого верхнего уровня. До ошибки из середины «матрешки» через приведение типа не добраться. А вот через `errors.As()` — можно:

```go
descr, err := langs.describe("java")
// обернем еще раз, чтобы languageErr
// оказалась внутрь матрешки
err = fmt.Errorf("wrap once more: %w", err)

var langErr languageErr
if errors.As(err, &langErr) {
    fmt.Println("Language error:", langErr.lang)
}
```

```
Language error: java
```

`errors.As()` проверяет каждый слой ошибки, и если видит там искомый тип `languageErr` — заполняет значение `langErr` по переданному указателю, и возвращает `true`. Если искомого типа нет — возвращает `false`.

[песочница](https://go.dev/play/p/mDY0C-7E32A)

Итого по обертыванию:

- Простой способ создать новую ошибку на основе существующей — `fmt.Errorf()` и спецификатор `%w`
- Если нужен собственный тип ошибки, придется добавить в него поле типа `error` и метод `Unwrap()`
- `errors.Is()` проверяет конкретную ошибку на каждом слое.
- `errors.As()` заполняет ошибку конкретного типа, если он встречается на одном из слоев.

Важное различие между `Is` и `As`: `errors.Is` ищет ошибку по совпадению _значения_ ошибки, а `errors.As` по совпадению _типа_ ошибки. Прежде чем двигаться дальше, проработайте примеры выше и убедитесь, что вы в этом разобрались.

### **Комбинация ошибок**

Если во время выполнения функции или метода произошла ошибка, обычно мы сразу ее возвращаем. Но иногда, если ошибок может быть несколько, полезно собрать их все и потом уже вернуть. В старых версиях Go сделать это можно было только вручную — например, завести срез с ошибками, заполнить его и вернуть. А в Go 1.20+ появился простой способ комбинации ошибок через `errors.Join()`:

```go
errRaining := errors.New("it's raining")
errWindy := errors.New("it's windy")
err := errors.Join(errRaining, errWindy)
```

Теперь `err` — это одновременно `errRaining` и `errWindy`. Стандартные функции `errors.Is()` и `errors.As()` умеют с этим работать:

```go
if errors.Is(err, errRaining) {
    fmt.Println("ouch! it's raining")
}
// ouch! it's raining

if errors.Is(err, errWindy) {
    fmt.Println("ouch! it's windy")
}
// ouch! it's windy
```

`fmt.Errorf()` тоже научилась комбинировать ошибки:

```go
err := fmt.Errorf("reasons to skip work: %w, %w", errRaining, errWindy)
fmt.Println(err)
// reasons to skip work: it's raining, it's windy
```

Чтобы принимать множественные ошибки в собственном error-типе, достаточно вернуть `[]error` вместо `error` из метода `Unwrap()`:

```go
type RefusalErr struct {
    reasons []error
}

func (e RefusalErr) Unwrap() []error {
    return e.reasons
}

func (e RefusalErr) Error() string {
    return fmt.Sprintf("refusing: %v", e.reasons)
}

err := RefusalErr{[]error{errRaining, errWindy}}
if errors.Is(err, errRaining) {
    fmt.Println("ouch! it's raining")
}
// ouch! it's raining
```

[песочница](https://go.dev/play/p/CftXuesNA1q)

### **Дополнительное чтение**

Спецификация: [errors](https://go.dev/ref/spec#Errors) • [defer](https://go.dev/ref/spec#Defer_statements) • [panic / recover](https://go.dev/ref/spec#Handling_panics)

[Defer, Panic, and Recover](https://go.dev/blog/defer-panic-and-recover)

[Effective Go: Errors](https://go.dev/doc/effective_go#errors)

[Errors are values](https://go.dev/blog/errors-are-values)

[Working with Errors in Go](https://go.dev/blog/go1.13-errors)