Go не поддерживает ООП в классическом виде (нет классов и наследования), но **все 4 принципа реализуются через struct + interface**:
**struct** — как “объекты”: могут содержать данные (поля) и методы.
**interface** — как “контракты”: описывают поведение без реализации.
### **Абстракция**
 В Go абстракция реализуется через интерфейсы — они описывают поведение, но не зависят от конкретной структуры.
```go
type Speaker interface {
	Speak()
}
```
### **Инкапсуляция**
**Что это**: скрытие внутренней реализации.
**В Go**: через **регистр**:
- Name — экспортируемое (публичное).
- name — неэкспортируемое (приватное).
```go
type User struct {
	name string // приватно
	Age  int    // публично
}
```
### **Полиморфизм**
**Что это**: один интерфейс — много реализаций.
**В Go**: если тип реализует методы интерфейса — можно его использовать как этот интерфейс.
```go
type Cat struct{}
func (Cat) Speak() { fmt.Println("meow") }

func Talk(s Speaker) {
	s.Speak()
}
```
### **Наследование**
**Что это**: возможность переиспользовать поведение базового типа.
**В Go нет наследования**, но есть **встраивание (embedding)** — почти то же самое.
```go
type Animal struct {
	Name string
}

func (a Animal) Sleep() { fmt.Println(a.Name, "sleeps") }

type Dog struct {
	Animal // встраиваем
}

func main() {
	d := Dog{Animal{Name: "Bobik"}}
	d.Sleep() // Dog унаследовал метод Animal
}
```
> Go не имеет классов и наследования, но все ООП-принципы реализуются через структуры и интерфейсы. Наследование заменено встраиванием, абстракция и полиморфизм — через интерфейсы, инкапсуляция — через регистр идентификаторов. Всё просто и прозрачно.
### **Что такое интерфейс в Go?**
**Интерфейс** — это **набор методов**, без реализации.
Если тип реализует все методы интерфейса — он **неявно** удовлетворяет интерфейсу.
```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```
### **Как устроен интерфейс внутри?**
Интерфейс — это **2 поля**:
- type — конкретный тип (например, *Dog)
- data — значение (указатель или значение)
```go
var a interface{} = 42
// a = {type: int, data: 42}
```
### **Зачем нужен пустой интерфейс (interface{})?**
**Это “любой тип”**. Всё в Go можно положить в interface{}.
Применения:
- универсальные контейнеры ([]interface{})
- JSON-структуры (map[string]interface{})
- логгеры, middleware и т.д.
> interface{} — универсальный контейнер для любого значения. Но теряем типизацию, нужна проверка через type assertion.
### **Чем interface{} отличается struct{}?**

||interface{}|struct{}|
|---|---|---|
|Содержит|тип и данные|ничего (0 байт)|
|Используют|для **поведения**|для **структуры**|
|Размер|2 слова|0 байт|
> interface{} — поведенческий тип, может хранить что угодно. struct{} — пустая структура, ничего не несёт.
### **Что если интерфейс содержит nil-указатель?**
Вот код:
```go
type Dog struct{}
func (d *Dog) Speak() { fmt.Println("woof") }

var d *Dog = nil
var a interface{} = d

fmt.Println(a == nil) // false!
```
**Почему false?**
Потому что a содержит type=*Dog, data=nil.
То есть **интерфейс не пустой** — у него есть тип.
### Чем отличается работа с ошибками в Go от других языков?
- В Go **ошибки — это обычные значения** типа error, а не исключения.
- **Нет try/catch**. Вместо этого ошибки возвращаются вторым значением:
```go
val, err := doSomething()
if err != nil {
	return err
}
```
**Главное отличие**: ошибки — это часть обычного управления, а не экстренный механизм.
### **Какая парадигма обработки ошибок?**
> **Explcit error handling** (явная работа с ошибками).

Go требует, чтобы ты **явно проверял ошибки** после каждого вызова. Это упрощает контроль потока и делает поведение очевидным.
### **Какие функции есть для оборачивания и сравнения ошибок?**
Начиная с Go 1.13:
- fmt.Errorf("context: %w", err) — оборачивание ошибки с сохранением оригинала.
- errors.Is(err, target) — проверка, есть ли в цепочке ошибка target.
- errors.As(err, &targetType) — приведение к нужному типу ошибки.
Важное различие между `Is` и `As`: `errors.Is` ищет ошибку по совпадению _значения_ ошибки, а `errors.As` по совпадению _типа_ ошибки. 
### **Для чего используется panic?**
panic = **аварийное завершение горутины**. Используется, когда:
- нарушение инварианта (например, index out of range)
- ошибка, которую нельзя обработать
- внутри must-функций (инициализация, тесты и т.д.)
**Важно**: это не для обычных ошибок! Только критических.
### **Как работает recover ?**
recover() вызывается внутри defer и **останавливает панику**. Позволяет “спасти” горутину.
```go
func safe() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("caught:", r)
		}
	}()
	panic("boom") // будет поймано
}
```
### **recover работает только в той горутине, где panic**
```go
func main() {
	defer func() {
		if r := recover(); r != nil {
			fmt.Println("RECOVERED") // ❌ не сработает
		}
	}()

	go func() {
		panic("boom") // ← в другой горутине
	}()
}
```
Почему не сработает?
- panic — в новой горутине
- recover — в main-горутине
- В разных горутинах — recover не ловит

> Go не использует исключения. Ошибки — обычные значения, обрабатываются явно.
> Есть errors.Is, errors.As и оборачивание через %w.
> Panic — для критических ситуаций. Recover — ловит только в defer той же горутины.

