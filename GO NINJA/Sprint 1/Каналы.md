- **Что такое каналы?**
это механизм для синхронизации и обмена данными между горутинами. Они являются важной частью модели конкуренции Go, обеспечивая безопасный способ передачи данных между параллельными потоками выполнения.
- **Как устроен канал и как он работает под капотом?**
Аллоцируются на куче. Указатель на объект структуры 
```go
type hchan struct {
    qcount   uint           // сколько элементов сейчас в буфере
    dataqsiz uint           // ёмкость буфера
    buf      unsafe.Pointer // указатель на массив-буфер
    elemsize uint16
    cloded   uint32
    sendx    uint           // индекс для отправки
    recvx    uint           // индекс для получения
    recvq    waitq          // очередь ожидающих приём
    sendq    waitq          // очередь ожидающих отправку
    lock     mutex          // защита доступа к каналу
}
```
Обладает семантикой FIFO. Во время работы с каналом горутины могут изменять своё состояние (running, waiting, runnable) с помощью планировщика, для этого нужны две очереди sendq и recvq, там хранятся горутины, которые стоят на паузе.

 В случае, когда есть спящий sender, его “разбудит” пришедшая горутина reciever после того, как освободит ячейку буфера для его данных, sender перейдёт в состояние runnable.
В случае, когда есть спящий reciever, пришедший sender переместит данные из своего стека напрямую в стек спящей горутины-получателя, эта оптимизация позволяет избежать лишнего копирования данных. Это один из двух случаев рантайма Go, где одна горутина получает доступ к стеку другой (второй — это небезбуферизованные каналы, они кладут и берут данные напрямую из стеков друг друга).
- **Какие есть типы каналов в Golang?**
не буферизованные и буферизованные
- **Что если писать/читать в закрытый канал?**
Если вы пытаетесь записать значение в закрытый канал в Go, это вызовет панику (panic).
Чтение из закрытого канала всегда успешно, но возвращает zero-value и ok=false.
- **Чем отличается запись/чтение в буферизованном и небуферизованном канале?**
В случае с не буферизованным каналом запись блокирует отправляющую горутину до тех пор, пока другая горутина не выполнит чтение из канала. Чтение блокирует читающую горутину, пока другая не выполнит запись.
В случае с буферизованным каналом запись будет блокирующей только в случае, если буфер заполнен. Чтение блокирует читающую горутину только если буфер пуст.
- **Что если закрыть закрытый канал?**
Это вызовет панику (panic).
- **Какие операции есть с каналами?**
Создание канала (make). Отправка данных в канал (ch <- value). Получение данных из канала (value := <-ch). Закрытие канала (close(ch)). Выбор из нескольких каналов (select).
**Почему closed 32 бита?**
Функции в. `atomic` минимально с 32битными значениями  
