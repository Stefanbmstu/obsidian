**Что такое map?**
**Map** — это хеш-таблица: отображение ключ → значение.

```
m := map[string]int{"a": 1, "b": 2}
```

Поддерживает:
- чтение: v := m["a"]
- вставку: m["c"] = 3
- удаление: delete(m, "a")
- проверку наличия: v, ok := m["key"]

**Как устроена map под капотом?**
- Основа — **хеш-таблица с open addressing** и **bucket’ами**.
- Каждый **bucket** хранит до 8 пар key-value (в массивах).
- При росте мапы запускается **grow** — создаётся новая таблица в 2× больше.
- Во время чтения/записи происходит **эвакуация** старых bucket’ов в новые.

**Какие ключи допустимы?**
Ключи должны быть **comparable** — можно сравнивать через `==`.
Разрешены:
- числа, строки, bool
- указатели, каналы, интерфейсы (если сравнимы)
- массивы фиксированной длины (если элементы сравнимы)
- структуры (если все поля сравнимы)
❌ **Слайсы, мапы, функции** — не подходят, они не сравнимы.

**Что произойдёт при конкурентной записи в map?**

```go
go func() { m["a"] = 1 }()
go func() { m["b"] = 2 }()
```

→ **паника во время выполнения** (fatal error: concurrent map writes).
**map в Go — не потокобезопасна.**

**Как работает эвакуация (grow)?**
- Когда загрузка мапы растёт, создаётся новая таблица.
- При доступе к элементу, его **одновременно перемещают** в новую таблицу.
- Это **инкрементально**, чтобы не было паузы (copy-on-access).

**Потокобезопасна ли map?**
Нет. **Нельзя читать и писать в обычную мапу из разных горутин.**

**Map vs sync.Map**
||map[K]V|sync.Map|
|---|---|---|
|Безопасна|❌|✅|
|Подходит для|локального доступа|конкурентного доступа|
|Поддерживает range|✅|❌ (есть Range(fn))|
|Хеш-таблица|да|да, но с внутренними трюками|

synс.Map быстрее при **редких обновлениях и частом чтении**, но хуже при плотной записи.

**Можно ли взять адрес элемента map?**

```go
p := &m["a"] // ❌ нельзя — может быть перемещено
```

**Нельзя брать адрес элемента мапы**, потому что:
- значение может **переместиться** при grow/эвакуации
- это приведёт к **висячему указателю** (invalid pointer)
    

**Сложность операций**
- Чтение, вставка, удаление: **O(1)** в среднем
- В худшем случае: **O(n)** (при коллизиях или эвакуации)

**Что такое слайс?**
Слайс — это **представление окна над массивом**.
Он хранит:
- указатель на массив
- длину (len)
- вместимость (cap)

```go
s := []int{1, 2, 3} // слайс, не массив
```

**Чем массив отличается от слайса?**

```go
var a [3]int     // массив: фиксированная длина
var s []int      // слайс: гибкий, может расти
```

||**Массив**|**Слайс**|
|---|---|---|
|Размер|фиксирован|динамический|
|Передача|по значению|по ссылке|
|Производительность|быстрее (без аллокаций)|гибче, но может realloc’иться|

**Плюсы массива**:
- известный размер на этапе компиляции
- нулевая аллокация, меньше накладных расходов

**Как работает append?**

```go
s := []int{1, 2}
s = append(s, 3)
```

- Если cap хватает — просто записывает.
- Если cap не хватает — **создаёт новый массив ×2**, копирует всё туда.
→ append **может поменять адрес underlying массива** → старые ссылки станут невалидны.

**Оптимизация работы со слайсами**
1. **Предвыделить память**:
```go
make([]int, 0, 1000) // избегаем лишних аллокаций
```
2. **Избегать копирования при append** — не передавать слайсы по значению.
3. **Использовать copy(dst, src)** — быстрее, чем append поэлементно.
4. **Не брать адрес из слайса, если его cap может измениться.**
    

**Как создать слайс с длиной > 0?**
```go
make([]int, 10)       // len=10, cap=10
make([]int, 5, 100)   // len=5, cap=100
```
Функция make создаёт слайс с заранее заданной длиной и/или вместимостью.

**С какой скоростью идёт поиск в массиве?**
- **O(n)** — линейный перебор, если нет сортировки.
- **O(1)** — только по индексу (arr[i])
- Нет встроенного бинарного поиска — надо писать руками (или использовать sort.Search для отсортированных массивов).

**Почему?**
Потому что обычный []T — это просто последовательность значений.
Нет ни индексов, ни хешей → только перебор.

**Что такое канал?**
**Канал (chan)** — это **потокобезопасная очередь**, через которую горутины обмениваются данными.
```go
ch := make(chan int)
ch <- 1        // отправка
v := <-ch      // получение
```

**Как устроен канал под капотом?**
Канал — это:
- кольцевой буфер (если буферизован)
- очередь горутин, ожидающих отправку или приём
- мьютекс и условия (cond vars)
Для синхронного канала (без буфера) — передача значения = встреча send и recv.

**Какие бывают типы каналов?**
- **Буферизованные**: make(chan T, N)
    - хранит до N элементов
- **Небуферизованные**: make(chan T)
    - блокируют отправителя до получения
- **Однонаправленные**: chan<- T (только send), <-chan T (только receive)

**Что если писать/читать в закрытый канал?**

|**Операция**|**Результат**|
|---|---|
|close(ch)|закрывает канал|
|ch <- x в закрытый|**паника** (send on closed chan)|
|<-ch из закрытого|возвращает zero value, ok = false|
|close(ch) дважды|**паника**|
**Какие операции возможны с каналами?**
- ch <- val — отправка
- <-ch — получение
- val, ok := <-ch — безопасное чтение
- close(ch) — закрытие
- select { case ... } — множественный выбор
- range ch — читать до закрытия

**Как сделать буферизованный канал?**
```go
ch := make(chan int, 10)
```
- len(ch) — текущая заполненность
- cap(ch) — размер буфера

**Какие параметры бывают у каналов?**
- Направление: chan, chan<-, <-chan
- Буфер: 0 (синхронный) или N (асинхронный)
- Тип: chan int, chan string, и т.д.

**Для чего используется select?**
select — позволяет **ждать несколько операций на каналах одновременно**.
```go
select {
case x := <-ch1:
	// прочли из ch1
case ch2 <- 42:
	// записали в ch2
default:
	// если ничего не готово
}
```
- Работает как **switch по готовым каналам**.
- Один из готовых кейсов выбирается **случайно**, если их несколько.

**Что если закрыть уже закрытый канал?**
```go
close(ch)
close(ch) // ← паника
```

**Что произойдёт с читателями и писателями, если закрыть канал?**
- **Читатели**: могут читать до опустошения, потом получают zero, false
- **Писатели**: при попытке записи → **паника**

  