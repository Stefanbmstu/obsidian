**Отличие мапы в 1.24**
Раньше было так, что все ключи по очереди загружались и сравнивались с искомым значением, соответственно кеш мог вымыться, т.к. могла вклиниться другая операция, а потом опять приходилось всё загружать, а так мы в касание делаем поиск и в крайних случаях кеш проца может вымыться.
- Хэш (64 бита) разбивается: старшие 57 бит (H1) определяют группу, младшие 7 бит (H2) служат метаинформацией.
- Вместо бакетов теперь группы по 8 элементов. Каждый элемент хранит 7 бит H2 + 1 бит занятости.
- Используется SIMD: можно сразу загрузить всю группу и сравнить H2, получив маску совпадений. Это сильно ускоряет поиск и уменьшает нагрузку на кеш процессора.
- Группы хранятся подряд в памяти, что улучшает локальность данных.
- Ресайз/перебалансировка теперь при 80% средней заполненности.  

**Что такое мапа?**
`map` в Go — это коллекция пар ключ-значение. Это указатель на объект структуры  `hmap` (срез - это объект структуры).
`map` автоматически увеличивает размер при добавлении новых элементов и  обеспечивает доступ к значениям по ключу за постоянное время O(1). Под капотом используется структура данных хэш-таблица.
**Что произойдет при конкурентной записи в мапу?**
При конкурентной записи в `map` в Go могут возникнуть **гонки данных** (data races), которые могут привести к непредсказуемому поведению программы, включая краши.
**Как устроена мапа под капотом?**
Под капотом мапа по сути хэш-таблица. Под капотом все операции выполняются через `unsafe.Pointers`, мета-информация о типе хранится в `type descriptor`, `type descriptor` предоставляет операции `equal` и `copy`. Порядок обхода мапы всегда случайный, при выводе мапы через `fmt.Println` выводятся отсортированные ключи и значения.
**Структура мапы:** есть структура, некий **хедер**, который хранит в себе общую информацию (размер, `log2(buckets count)`, указатель на бакеты, `hash seed`).
**Структура бакетов:**  над самим бакетом есть `low order bits` - остаток от деления хэша на кол-во бакетов; внутри бакета есть 8 слотов для `high order bits` для быстрой проверки наличия ключа в бакете, ключи и значения лежат друг за другом (8 ключей, 8 значений), такой порядок связан с выравниванием типов.
**Переполнение бакетов:** создаётся новый бакет и ссылка на него сохраняется в изначальном бакете.
**Рост мапы:** мапа будет расти при `loadfactor` == 6.5 (в каждом бакете в среднем 6.5 значений), далее будет происходить эвакуация данных.
**Какие ключи могут быть у мапы?**
В Go ключи для `map` могут быть любого типа, который поддерживает операции сравнения (`==` и `!=`). Это означает, что ключи должны быть сопоставимыми (comparable).
**Какая сложность работы с мапой?**
В среднем О(1)
**Как работает эвакуация данных?**
Создаётся новый список бакетов, который будет в 2 раза больше предыдущего, данные из старых бакетов будут скопированы в новые. Память выделяется сразу, а инициализация (перенос данных) происходит в те моменты, когда выполняются операции сохранения или удаления ключей из мапы. Из-за процесса эвакуации мы не можем взять указатель на элемент мапы.
**Как разрешаются коллизии в мапе?**
Go использует открытую адресацию с бакетами. overflow bucket
**Как достигается константная сложность работы с мапой?**
Благодаря фиксированному размеру бакетов, а также благодаря использованию хеш-таблиц в качестве внутренней структуры данных.
**Чем мапа отличается от sync.Map?**
sync.Map потокобезопасна и может быть менее производительная. Также семантика работы (`Load`, `Store`, `LoadOrStore`, `Delete`, и `Range`)

