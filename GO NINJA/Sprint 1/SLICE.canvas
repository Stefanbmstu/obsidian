{
	"nodes":[
		{"id":"c041ccedd594105e","type":"text","text":"### Подслайсы и побочные эффекты\n\n```go\narr := []int{1, 2, 3, 4, 5}\ns1 := arr[1:4] // [2 3 4]\ns2 := s1[:2]   // [2 3], но тот же underlying array\n```\n\n- Если изменить `s1[0] = 99`, это повлияет и на `arr`\n    \n- Если вызвать `append()` и **cap ещё позволяет** — модификация произойдёт в старом массиве\n    \n- Если cap превышен — создастся новый массив, связь с оригиналом теряется\n\nЧтобы гарантированно отделиться от общего массива:\n\n```go\ns2copy := make([]int, len(s2))\ncopy(s2copy, s2)\n```","x":-122,"y":180,"width":683,"height":423,"color":"2"},
		{"id":"410824998b5a5aee","type":"text","text":"### Аллокация и производительность\n\n- Если заранее известен объём данных — всегда **предварительно аллоцируем** слайс через `make` с нужной capacity.\n- Это критично для производительности в циклах — избегает многократных пересозданий и копирования.\n\n**Вариант с `range`:**\n\n```go\ninput := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\noutput := make([]int, 0, len(input)) // аллокация заранее\nfor _, v := range input {\n    output = append(output, v)\n}\n```\n\n✅ `range` читает значения, `append` идёт в заранее выделенный буфер — никакой лишней аллокации.\n\n**Ещё лучше — запись по индексу:**\n\n```go\noutput := make([]int, len(input))\nfor i, v := range input {\n    output[i] = v\n}\n```\n\n✅ Это ещё быстрее: без `append`, без изменения `len`, без лишней логики.\n\nЧтобы «очистить» срез, сохранив буфер и cap, часто делают s = s[:0] вместо s = nil. Это позволяет переиспользовать выделенную память в циклах и избежать новых аллокаций.","x":-165,"y":-1000,"width":771,"height":700,"color":"2"},
		{"id":"fbd7d5b6bd32bbd6","type":"text","text":"### 11. Низкоуровневый доступ\n\n- Используя `reflect.SliceHeader`, можно увидеть:\n    \n\n```go\ntype SliceHeader struct {\n    Data uintptr // указатель\n    Len  int\n    Cap  int\n}\n```\n\n- Это полезно для отладки, но требует осторожности","x":771,"y":-240,"width":619,"height":320,"color":"6"},
		{"id":"cc4bd0cacb0f04eb","type":"text","text":"### 12. Строки vs []byte\n\n- Строки: `ptr + len`, **без cap**, **иммутабельны**\n    \n- `[]byte(\"hello\")` → `string` создаёт **новую копию**\n    \n- Можно избежать копии через `unsafe`, но это **небезопасно**:\n    \n\n```go\nb := []byte(\"hi\")\ns := *(*string)(unsafe.Pointer(&b)) // ⚠️ может привести к багам\n```","x":770,"y":180,"width":620,"height":260,"color":"6"},
		{"id":"05d17d675853cb32","type":"text","text":"### Пример кастомного append (ручное управление памятью)\n\n```go\nfunc AppendInt(slice []int, val int) []int {\n    l := len(slice)\n    if l < cap(slice) {\n        // Есть место — расширяем слайс и вставляем элемент\n        slice = slice[:l+1]\n    } else {\n        // Места нет — создаём новый массив с увеличенным cap\n        newCap := cap(slice) * 2\n        if newCap == 0 {\n            newCap = 1\n        }\n        newSlice := make([]int, l+1, newCap)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice[l] = val\n    return slice\n}\n```\n\n- Демонстрирует ключевой принцип: **append возвращает новый слайс**, особенно при превышении `cap`\n    \n- Подходит как шаблон при реализации собственных коллекций или буферов","x":700,"y":-963,"width":760,"height":623,"color":"2"},
		{"id":"b5601d5ae7e33a6d","type":"text","text":"### Работа с большими буферами\n\n- Частая ошибка: взять маленький слайс из большого буфера → GC не может освободить память:\n    \n\n```go\nbuf := make([]byte, 1<<20) // 1 MB\nsmall := buf[:10]          // cap ≈ 1MB → buf не будет освобожден\n```\n\nЛучше скопировать:\n\n```go\nc := make([]byte, len(small))\ncopy(c, small)\nsmall = c\n```","x":-60,"y":-240,"width":560,"height":380,"color":"2"},
		{"id":"f019caf43ccebe55","type":"text","text":"### nil vs пустой слайс\n\n```go\nvar a []int          // nil-слайс, a == nil → true\nb := []int{}         // пустой, но не nil → false\n```\n\n- Для проверки лучше использовать:\n    \n\n\n```go\nif len(a) == 0 { /* пусто */ }\n```\nВиды инициализации слайсов:\n```go\ns := []int{}          → empty (s != nil, len = 0)\ns := make([]int, 0)   → zero  (s != nil, len = 0, cap ≥ 0)\nvar s []int           → nil   (s == nil, len = 0, cap = 0)\n```\n\n","x":-160,"y":688,"width":573,"height":432,"color":"2"},
		{"id":"e76f894258990271","type":"text","text":"### Очистка и удаление элементов\n\n```go\ns = s[:0]         // очистка, cap сохраняется\ns = s[1:]         // удалить первый\ns = s[:len(s)-1]  // удалить последний\n\n// Удалить i-й без сохранения порядка:\ns[i] = s[len(s)-1]\ns = s[:len(s)-1]\n```","x":500,"y":904,"width":479,"height":256,"color":"2"},
		{"id":"3caae4c9c3602016","type":"text","text":"### Best Practices\n\n- ✅ Всегда присваивай результат `append`: `s = append(s, x)`\n    \n- ✅ Используй `copy()` для изоляции от больших буферов или чужих слайсов\n    \n- ✅ Проверяй пустоту через `len(s) == 0`\n    \n- ✅ Аллоцируй заранее, если знаешь объём: `make([]T, 0, cap)`\n    \n- ✅ Не полагайся на реализацию `cap` роста\n    \n- ⚠️ Не сравнивай слайсы напрямую: Go < 1.21 — `reflect.DeepEqual`, Go ≥ 1.21 — `slices.Equal`\n    \n- ⚠️ Слайсы не потокобезопасны — защита через sync/mutex при работе из нескольких goroutine\n    \n- ⚠️ Не забывай: подслайсы могут удерживать большие массивы в памяти","x":700,"y":533,"width":845,"height":310,"color":"1"},
		{"id":"41b146bd82914348","type":"text","text":"### Что такое слайс\n\nСлайс — это динамическое представление части массива. Он состоит из трёх компонентов:\n```go\nstruct Slice {\n    ptr *T    // указатель на первый элемент\n    len int   // длина слайса\n    cap int   // вместимость (от ptr до конца массива)\n}\n```\n`[]int` → 24 байта (ptr+len+cap)\n- Слайс не содержит самих данных, он — \"окно\" в массив\n- Может ссылаться на часть или весь массив\n- Несколько слайсов могут указывать на один и тот же массив","x":-796,"y":-1000,"width":580,"height":420,"color":"2"},
		{"id":"f6f02a9e98f88cf5","type":"text","text":"### Отличия от массивов\n\n- Массивы:\n    \n    - фиксированной длины\n        \n    - передаются по значению (копируются)\n        \n\n```go\nfunc f(arr [3]int) { arr[0] = 999 } // не изменит оригинал\n```\n\n- Слайсы:\n    \n    - динамичные\n        \n    - содержат указатель, длину, емкость\n        \n    - копируются по значению, но **делят память** массива\n        \n\n```go\nfunc f(slice []int) { slice[0] = 999 } // изменит оригинал\n```","x":-796,"y":-550,"width":580,"height":420,"color":"2"},
		{"id":"577e3ee793769cb7","type":"text","text":"### Поведение append, мутация и передача в функцию\n\n- `append()` увеличивает длину слайса:\n    \n    - если `len < cap`, данные добавляются в тот же массив\n        \n    - если `len == cap`, создаётся новый массив, и копируются все элементы\n        \n\n```go\ns := []int{1, 2, 3}\ns = append(s, 4) // обязательно сохранить результат\n```\n\n- При передаче в функцию слайс копируется по значению — структура (`ptr`, `len`, `cap`), но **не** данные storage:\n    \n\n```go\nfunc modify(s []int) []int {\n    s[0] = 99           // это отразится на оригинале\n    s = append(s, 100)  // создаст новый слайс, если cap исчерпан\n    return s            // вернуть обязательно\n}\n\ns := []int{1, 2, 3}\ns = modify(s) // сохранить результат извне\n```","x":-826,"y":-80,"width":640,"height":578,"color":"2"},
		{"id":"c4ad38f66e89d852","type":"text","text":"### Копия слайса vs копия данных\n\n```go\ns1 := []int{1, 2, 3}\ns2 := s1       // копия структуры, те же данные\ns2[0] = 9      // изменит s1\n\ns3 := make([]int, len(s1))\ncopy(s3, s1)   // копия данных\ns3[0] = 100    // s1 не изменится\n```","x":-756,"y":520,"width":500,"height":247,"color":"2"},
		{"id":"0dae9cd0ff016bfb","type":"text","text":"### Рост capacity\n\n- Реализация `append()` (в runtime):\n    \n    - пока `cap ≤ 1024` → удваивает размер\n        \n    - при `cap > 1024` → +25%\n        \n    - может отличаться в будущих версиях","x":-750,"y":814,"width":488,"height":180,"color":"2"}
	],
	"edges":[
		{"id":"a9a716064a140b9e","fromNode":"41b146bd82914348","fromSide":"bottom","toNode":"f6f02a9e98f88cf5","toSide":"top","color":"2"},
		{"id":"04293908b2ad7e8b","fromNode":"577e3ee793769cb7","fromSide":"bottom","toNode":"0dae9cd0ff016bfb","toSide":"top","color":"2"},
		{"id":"e15a923f6cf93967","fromNode":"f6f02a9e98f88cf5","fromSide":"bottom","toNode":"577e3ee793769cb7","toSide":"top","color":"2"},
		{"id":"19d34c86c4f23599","fromNode":"0dae9cd0ff016bfb","fromSide":"right","toNode":"f019caf43ccebe55","toSide":"left","color":"2"},
		{"id":"5d781c6e341d7bfa","fromNode":"f019caf43ccebe55","fromSide":"top","toNode":"c041ccedd594105e","toSide":"bottom","color":"2"},
		{"id":"b05d525c1a5cef5b","fromNode":"c041ccedd594105e","fromSide":"top","toNode":"b5601d5ae7e33a6d","toSide":"bottom","color":"2"},
		{"id":"b427af9334f9d3e7","fromNode":"b5601d5ae7e33a6d","fromSide":"top","toNode":"410824998b5a5aee","toSide":"bottom","color":"2"},
		{"id":"d93c8a92c0e35d31","fromNode":"410824998b5a5aee","fromSide":"right","toNode":"05d17d675853cb32","toSide":"left","color":"2"},
		{"id":"cfa4ea590307dd34","fromNode":"05d17d675853cb32","fromSide":"bottom","toNode":"fbd7d5b6bd32bbd6","toSide":"top","color":"6"},
		{"id":"602e4c018dacc707","fromNode":"fbd7d5b6bd32bbd6","fromSide":"bottom","toNode":"cc4bd0cacb0f04eb","toSide":"top","color":"6"},
		{"id":"81c2f04f84439f6b","fromNode":"e76f894258990271","fromSide":"left","toNode":"f019caf43ccebe55","toSide":"right","color":"2"}
	]
}