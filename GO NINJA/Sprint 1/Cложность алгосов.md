**асимптотический анализ**
- Оценивает эффективность алгоритма по **числу операций**, а не по времени выполнения.
- Позволяет сравнивать алгоритмы независимо от железа.
- Описывает поведение при **росте входных данных** (n → ∞).
**Нотации асимптотики**

|**Нотация**|**Значение**|**Комментарий**|
|---|---|---|
|O(…)|Верхняя граница|Худший случай (используется чаще всего)|
|Ω(…)|Нижняя граница|Лучший случай (редко)|
|Θ(…)|Точная оценка|Средний случай (почти не используется)|

Пример (линейный поиск): O(n) — в худшем случае, Ω(1) — в лучшем.
**Основные классы сложности (по возрастанию трудоёмкости)**

|**Название**|**Нотация**|
|---|---|
|Константная|O(1)|
|Логарифмическая|O(log n)|
|Линейная|O(n)|
|Линейно-логарифмическая|O(n log n)|
|Квадратичная|O(n^2)|
|Кубическая|O(n^3)|
|Степенная|O(2^n)|
|Факториальная|O(n!)|

**Худший / Средний / Лучший случай**

|**Сценарий**|**Обозначение**|**Пример (линейный поиск)**|
|---|---|---|
|Лучший|Ω(1)|Цель — первый элемент|
|Средний|Θ(n)|Цель — случайное место|
|Худший|O(n)|Цель — последний или отсутствует|

**Как считать сложность**
- Считаются **основные операции**: сравнение, присваивание, вызовы функций.
- **Отбрасываются**:
    - Константы (O(2n) → O(n))
    - Недоминирующие члены (O(n^2 + n) → O(n^2))
**Примеры:**

```go
// Линейный цикл:
for i := 0; i < n; i++ {
    ...
} // → O(n)

// Два последовательных цикла:
for i := 0; i < n; i++ { ... }
for j := 0; j < m; j++ { ... } // → O(n + m)

// Вложенные циклы:
for i := 0; i < n; i++ {
    for j := 0; j < m; j++ {
        ...
    }
} // → O(n * m)
```

**Пространственная сложность (память)**
- Оценивает зависимость используемой памяти от входных данных.
- Пример:
```
squares := make([]int, len(nums))
for i, v := range nums {
    squares[i] = v * v
}
```
→ O(n) по времени и O(n) по памяти
**Рекурсия и стек**
**Прямая рекурсия:**

```go
func sum(n int) int {
    if n == 0 {
        return 0
    }
    return n + sum(n-1)
} // O(n) время, O(n) память (глубина стека)
```
**Дерево рекурсии (Фибоначчи):**

```go
func F(n int) int {
    if n <= 1 { return 1 }
    return F(n-1) + F(n-2)
} // O(2^n) время, O(n) память
```
**Динамическое программирование (DP)**

```go
// Мемоизация
memo := make(map[int]int)
func F(n int) int {
    if n <= 1 { return 1 }
    if v, ok := memo[n]; ok {
        return v
    }
    memo[n] = F(n-1) + F(n-2)
    return memo[n]
} // O(n) время, O(n) память
```
**Амортизированная сложность**
Используется, если:
- Обычные операции дешёвые (O(1)), но иногда дорогие (O(n)).
- Пример: append() в динамический массив.
    - Большинство вставок O(1)
    - Иногда — перераспределение памяти → O(n)
    - В среднем: **амортизированное O(1)**

**Когда складываем / умножаем**
- O(n + m) — если два независимых блока (последовательно)
- O(n * m) — если вложенность (для каждого из n делается m действий)

**Пример: бинарный поиск**

```go
for left <= right {
    mid := (left + right) / 2
    if a[mid] == target {
        return mid
    } else if a[mid] < target {
        left = mid + 1
    } else {
        right = mid - 1
    }
} // → O(log n)
```

**Примечания:**
- O(n + log n) → O(n)
- O(n^2 + n) → O(n^2)
- O(n + m) — нельзя упростить, если n и m независимы

**Классификация алгоритмов: табличка для собеседования**

| **Категория**        | **Алгоритм / Структура**    | **Временная сложность**   | **Пространственная сложность** | **Комментарий**                    |
| -------------------- | --------------------------- | ------------------------- | ------------------------------ | ---------------------------------- |
| **Поиск**            | Линейный поиск              | O(n)                      | O(1)                           | Без предположений о данных         |
|                      | Бинарный поиск              | O(log n)                  | O(1)                           | Требует отсортированный массив     |
| **Сортировка**       | Пузырьковая                 | O(n^2)                    | O(1)                           | Простая, неэффективная             |
|                      | Быстрая сортировка (средн.) | O(n log n)                | O(log n)                       | Рекурсивная, нестабильная          |
|                      | Слиянием                    | O(n log n)                | O(n)                           | Стабильная, требует доп. память    |
| **Структуры данных** | HashMap (map в Go)          | O(1) avg / O(n) worst     | O(n)                           | В худшем случае — коллизии         |
|                      | Массив (slice)              | O(1) доступ, O(n) вставка | O(n)                           | Амортизированная вставка = O(1)    |
|                      | Очередь/стек                | O(1)                      | O(n)                           | Через срез или список              |
| **Рекурсия / DP**    | Фибоначчи (наивно)          | O(2^n)                    | O(n)                           | Дерево вызовов                     |
|                      | Фибоначчи (с кешем)         | O(n)                      | O(n)                           | DP с мемоизацией                   |
| **Графы**            | DFS/BFS                     | O(V + E)                  | O(V)                           | Обход в глубину/ширину             |
|                      | Поиск в ширину (queue)      | O(V + E)                  | O(V)                           | Очередь для уровней                |
| **Деревья**          | Баланс. BST (поиск/вставка) | O(log n)                  | O(n)                           | AVL, Red-Black Tree                |
| **Спец. случаи**     | append() в Go               | амортиз. O(1)             | O(n)                           | Копирование массива при расширении |

- n — количество элементов
- V — количество вершин в графе, E — рёбер