#### Что такое Kafka? 
Брокер сообщений, используется для стриминга данных в реальном времени, сбора логов, аналитики, построения очередей сообщений и других задач, связанных с потоками данных.

#### Персистентно ли Kafka хранит события (сообщения)?
Да, Kafka хранит события персистентно. Все сообщения записываются на диск и хранятся в течение заданного времени или до достижения заданного объема памяти (в зависимости от настроек).

#### Из чего состоит сообщение?
Key, Value и метаданные (Topic, Offset, Timestamp)

#### Что такое producer?
Это компонент или приложение, которое создает и отправляет сообщения в Kafka. Он указывает: топик, в который нужно отправить данные и опционально ключ для управления маршрутизацией.

#### Что такое топик?
Это логическая категория или поток сообщений, предназначенных для определенного типа данных. Все сообщения в Kafka группируются по топикам. 

#### Что такое партиция?
Это подмножество сообщений внутри топика. Топик разделен на одну или несколько партиций для масштабируемости и параллельной обработки. Каждая партиция хранит сообщения в упорядоченном виде (по смещению) и может обрабатываться независимыми потребителями.

#### Имеет ли клиент контроль в какую партицию попадет сообщение?
Да, клиент (producer) имеет контроль над выбором партиции. Это можно сделать несколькими способами:
1. Указать ключ, по которому Kafka рассчитает хэш и определит партицию.
2. Явно указать номер партиции, в которую следует отправить сообщение.
3. Если ни ключ, ни партиция не указаны, Kafka использует **round-robin** (циклическое распределение) для равномерной отправки в доступные партиции.

#### В какую партицию попадают сообщения с одинаковым ключом?
Сообщения с одинаковым ключом всегда попадают в одну и ту же партицию. Kafka использует хэш-функцию для вычисления номера партиции на основе ключа.

#### Что такое лидер партиции?
Это брокер, который отвечает за обработку всех операций записи и чтения для определенной партиции. Каждая партиция в Kafka имеет одного лидера, а остальные брокеры, которые хранят копии данных этой партиции, являются **репликами**.

#### С каких брокеров идет запись/чтение в партиции?
**Запись** всегда происходит через **лидера партиции**.
**Чтение** также идет через лидера, но может быть настроено на чтение из реплик, если включена конфигурация `isolation.level`.

#### Что такое контроллер в Kafka?
Это специальный брокер, который координирует управление кластером Kafka. Его задачи включают:
1. Назначение лидеров партиций.
2. Обнаружение изменений в состоянии брокеров (например, добавление нового или сбой существующего).
3. Управление репликацией и ISR (см. ниже).

#### Внутренняя работа контроллера, и выбор нового контроллера, если старый умер
1. **Работа контроллера**:
    1. Контроллер отслеживает состояние брокеров через **ZooKeeper** (или KRaft, если используется новая версия).
    2. Если брокер выходит из строя, контроллер переназначает лидеров партиций на доступные реплики.
    3. Контроллер обновляет метаданные, которые рассылаются всем брокерам и клиентам.
2. **Выбор нового контроллера**:
    1. Если текущий контроллер "умирает," ZooKeeper выбирает нового контроллера.
    2. Каждый брокер в кластере следит за состоянием контроллера в ZooKeeper через "ephemeral znode."
    3. Первый брокер, который успешно создаст znode для контроллера, становится новым контроллером.
####  Что такое ISR?
Это набор реплик, которые синхронизированы с лидером и успешно подтверждают получение и запись всех сообщений лидера.
Если реплика долго отстает, она исключается из ISR, что может повлиять на доступность данных в случае сбоя лидера.

#### Какие значения есть у настройки acks у продьюсера? 
1. **`acks=0`**:
    1. Продьюсер не ждет подтверждения от брокера.
    2. Минимальная задержка, но данные могут быть потеряны.
2. **`acks=1`**:
    1. Продьюсер ждет подтверждения только от лидера.
    2. Умеренная надежность, но возможна потеря данных, если лидер умрет до репликации.
3. **`acks=all`**:
    1. Продьюсер ждет подтверждения от всех реплик в ISR.
    2. Максимальная надежность, но высокая задержка.

#### Что такое consumer?
Это компонент, который читает сообщения из Kafka. Он подписывается на один или несколько топиков и читает сообщения из одной или нескольких партиций.

#### Как порядок чтения сообщений связан с порядком записи?
Kafka гарантирует порядок сообщений **внутри одной партиции**. Если сообщения записаны в порядке `A → B → C`, они будут прочитаны в том же порядке. Однако между партициями порядок не гарантируется.

#### Консьюмер сам запрашивает данные из брокера, или отправка сообщений инициируется брокером?
**Консьюмер сам запрашивает данные**.  
Kafka использует pull-модель: консьюмеры регулярно отправляют запросы на получение новых сообщений, что дает им гибкость в управлении скоростью обработки данных.

#### Что такое consumer group?
Это группа консьюмеров, работающих совместно для обработки сообщений из одного или нескольких топиков. Каждый консьюмер в группе отвечает за чтение сообщений из определенных партиций, чтобы избежать дублирования. Группы обеспечивают параллельную обработку данных и масштабируемость.
**Правило:** Одну партицию одновременно читает только один консьюмер внутри одной группы.

#### Удаляется ли сообщение из брокера после прочтения консьюмером?
Нет, сообщение **не удаляется** после чтения. Kafka сохраняет сообщения до истечения времени хранения (configurable via `log.retention.ms`) или до достижения максимального объема (configurable via `log.retention.bytes`). Это позволяет другим консьюмерам или группам читать те же сообщения позже.

#### Может ли консьюмер из какой-то группы читать несколько партиций одного топика?
Да, если количество партиций больше, чем количество консьюмеров в группе, один консьюмер будет обрабатывать несколько партиций. Например, если в топике 6 партиций, а в группе только 3 консьюмера, каждый будет читать 2 партиции.

#### Могут ли несколько консьюмеров из одной группы читать одну и ту же партицию?
Нет, одновременно одну партицию в рамках одной группы читает только один консьюмер. Это правило гарантирует, что сообщения не будут обработаны дважды внутри одной группы.

#### Что такое consumer Offset?
**Offset** — это смещение, уникальный номер каждого сообщения внутри партиции. Консьюмер отслеживает, до какого смещения он дочитал сообщения. Это позволяет возобновлять чтение с последнего обработанного сообщения после сбоя. и перепроигрывать сообщения, начиная с определенного offset.

#### Что такое коммит сообщения?
**Коммит сообщения** — это процесс сохранения текущего offset в хранилище, чтобы зафиксировать, до какого сообщения консьюмер обработал данные. Kafka поддерживает два типа коммитов:
1. **Автоматический (auto commit):** Offset записывается автоматически через заданные интервалы.
2. **Ручной (manual commit):** Консьюмер самостоятельно вызывает метод для записи offset.

#### Что хранится в топике __consumer_offsets?
Этот системный топик хранит информацию о **offset'ах** для каждой consumer group. В нем записываются:
1. Идентификатор группы.
2. Offset для каждой партиции, которую читает группа.
3. Метаданные (время последнего коммита и т.д.).

#### Что такое идемпотентный продьюсер?
**Идемпотентный продьюсер** гарантирует, что одно и то же сообщение не будет записано в топик несколько раз, даже если произошел сбой сети или повторная отправка. Это достигается за счет:
1. Уникального идентификатора продьюсера (`Producer ID`).
2. Счетчика последовательности сообщений (`Sequence Number`).
Идемпотентный продьюсер предотвращает **дублирование сообщений** при сбоях, обеспечивая строгую "exactly-once" семантику.

#### Какие есть гарантии доставки сообщений?
At most once, At least once, Exactly once.

#### Опишите варианты работы продьюсера с прочитанным сообщением для достижения той или иной гарантии доставки
1. **At most once**:
    1. Продьюсер не ждет подтверждений (`acks=0`) и не повторяет попытки отправки.
    2. Сообщение может быть потеряно, если произошла ошибка на уровне сети или брокера.
2. **At least once**:
    1. Продьюсер ожидает подтверждение от Kafka (`acks=1` или `acks=all`).
    2. Повторяет отправку сообщения в случае ошибки (включены `retries`).
    3. Возможны дубликаты, если сообщение успешно записано, но подтверждение не получено.
3. **Exactly once**:
    1. Используется идемпотентный продьюсер (`enable.idempotence=true`), чтобы избежать дубликатов.
    2. Для транзакций: включаются `transactional.id` и `enable.idempotence`.

#### Как консьюмер может обработать повторные сообщения корректно? 
Для обработки повторных сообщений:
1. **Идентификаторы сообщений:** Хранить обработанные `offset` или уникальные ключи сообщений в внешнем хранилище (например, базе данных).
2. **Идемпотентные операции:** Процессы обработки сообщений должны быть идемпотентными (например, обновление записи в БД вместо добавления новой).
3. **Коммит вручную:** Использовать ручной коммит оффсета, только если сообщение успешно обработано.

#### Когда можно добиться exactly-once гарантии и что такое транзакция в Kafka?
**Exactly-once гарантии** достигаются при использовании транзакций в Kafka:
1. Продьюсер и консьюмер взаимодействуют через транзакции.
2. Kafka связывает запись сообщений и коммит оффсета в одну атомарную операцию.
3. Требуется:
    1. Идемпотентный продьюсер (`enable.idempotence=true`).
    2. Консьюмер с настройкой `isolation.level=read_committed`.
**Транзакция в Kafka** — это механизм, позволяющий записывать сообщения в несколько топиков и партиций атомарно, а также фиксировать обработку сообщений.

#### Кто такой координатор группы и как он выбирается?
**Координатор группы** (Group Coordinator) — это брокер, который управляет консьюмер-группой, отслеживает её участников и выполняет ребалансировку. Он выбирается автоматически:
1. Каждый брокер отвечает за координаторство для части групп, используя хэширование ID группы.
2. Если брокер-кандидат выходит из строя, координаторство переназначается.

#### Кто такой лидер группы?
**Лидер группы** (Group Leader) — это один из консьюмеров группы, ответственный за распределение партиций между участниками группы во время ребалансировки.

#### Кто реализует логику (стратегии) распределения консьюмеров группы по патрициям топика?
Логика распределения определяется стратегией партиционирования, задаваемой клиентом, но непосредственно распределение выполняется **лидером группы** на основании этой стратегии.

#### Какие бывают стратегии распределения?
1. **Range**: Каждому консьюмеру назначается диапазон партиций.
2. **RoundRobin**: Партиции распределяются равномерно между всеми консьюмерами.
3. **Sticky**: Пытается сохранить текущее распределение, минимизируя изменения (используется для предотвращения дестабилизации).
4. **Custom**: Пользователь может задать свою стратегию.

#### Что такое ребалансировка группы и когда она случается?
**Ребалансировка группы** — это процесс перераспределения партиций между консьюмерами в группе. Это происходит, когда:
1. Консьюмер присоединяется или покидает группу.
2. Партиции топика изменяются (например, добавляются новые партиции).
3. Происходит сбой консьюмера или брокера.

#### Что такое static membership?
**Static membership** (статическое членство) — это механизм, позволяющий сохранять состояние группы и назначение партиций даже при кратковременных сбоях консьюмера. Это достигается через конфигурацию `group.instance.id`, которая задаёт уникальный идентификатор консьюмера.
Статическое членство:
1. Уменьшает время на ребалансировку.
2. Позволяет быстрее восстанавливать работу группы после перезапуска консьюмера.

