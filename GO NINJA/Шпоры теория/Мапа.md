+ **Отличие мапы в 1.24**
Полученный хэш = 64 бита, его бьют на две части, первая (H1 нужен для вычисления номера группы) занимает 57 бит (старшие) и вторая (H2) занимает 7 бит (младшие).  H2 используется как мета информация, каждый элемент группы занимает 1 байт = 8 бит, 7 бит - это H2 и ещё 1 бит заполненности (0 или 1). Вместо бакетов теперь группы, в группе 8 элементов (хотя SIMD - single instruction, multiple data, поддерживает 16 и вроде 16 на будущее делали хз, эта инструкция есть у новых поколений процессоров). SIMD позволяет загружать сразу всю группу и входные 7 бит H2 (в случае поиска), что сильно ускоряет процесс, на выходе получается тупо маска, которая покажет где в группе лежит искомый элемент.
Раньше было так, что все ключи по очереди загружались и сравнивались с искомым значением, соответственно кеш мог вымыться, т.к. могла вклиниться другая операция, а потом опять приходилось всё загружать, а так мы в касание делаем поиск и в крайних случаях кеш проца может вымыться.
Ещё группы лежат последовательно в памяти, что тоже ускоряет работу всего, ранее бакеты могли лежать где угодно.
Ресайз и перебалансировка мапы происходит теперь при средней заполненности в 80%.

- **Что такое мапа?**
`map` в Go — это коллекция пар ключ-значение. `map` автоматически увеличивает размер при добавлении новых элементов и обеспечивает доступ к значениям по ключу за постоянное время O(1). Под капотом используется структура данных хэш-таблица.

- **Что произойдет при конкурентной записи в мапу?**
При конкурентной записи в `map` в Go могут возникнуть **гонки данных** (data races), которые могут привести к непредсказуемому поведению программы, включая краши.

- **Как устроена мапа под капотом?**
Под капотом мапа по сути хэш-таблица. Под капотом все операции выполняются через `unsafe.Pointers`, мета-информация о типе хранится в `type descriptor`, `type descriptor` предоставляет операции `equal` и `copy`. Порядок обхода мапы всегда случайный, при выводе мапы через `fmt.Println` выводятся отсортированные ключи и значения.

**Структура мапы:** есть структура, некий **хедер**, который хранит в себе общую информацию (размер, `log2(buckets count)`, указатель на бакеты, `hash seed`).

**Структура бакетов:**  над самим бакетом есть `low order bits` - остаток от деления хэша на кол-во бакетов; внутри бакета есть 8 слотов для `high order bits` для быстрой проверки наличия ключа в бакете, ключи и значения лежат друг за другом (8 ключей, 8 значений), такой порядок связан с выравниванием типов.

**Переполнение бакетов:** создаётся новый бакет и ссылка на него сохраняется в изначальном бакете.

**Рост мапы:** мапа будет расти при `loadfactor` == 6.5 (в каждом бакете в среднем 6.5 значений), далее будет происходить эвакуация данных.

- **Какие ключи могут быть у мапы?**
В Go ключи для `map` могут быть любого типа, который поддерживает операции сравнения (`==` и `!=`). Это означает, что ключи должны быть сопоставимыми (comparable).

- **Какая сложность работы с мапой?**
В среднем О(1)

- **Как работает эвакуация данных?**
Создаётся новый список бакетов, который будет в 2 раза больше предыдущего, данные из старых бакетов будут скопированы в новые. Память выделяется сразу, а инициализация (перенос данных) происходит в те моменты, когда выполняются операции сохранения или удаления ключей из мапы. Из-за процесса эвакуации мы не можем взять указатель на элемент мапы.

- **Как разрешаются коллизии в мапе?**
Коллизии в `map` решаются с помощью методов цепочек (chaining).

- **Как достигается константная сложность работы с мапой?**
Благодаря фиксированному размеру бакетов, а также благодаря использованию хеш-таблиц в качестве внутренней структуры данных.

- **Чем мапа отличается от sync.Map?**
sync.Map потокобезопасна и может быть менее производительная. Также семантика работы (`Load`, `Store`, `LoadOrStore`, `Delete`, и `Range`)

