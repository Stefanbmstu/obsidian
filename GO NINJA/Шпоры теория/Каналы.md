- **Что такое каналы?**
это механизм для синхронизации и обмена данными между горутинами. Они являются важной частью модели конкуренции Go, обеспечивая безопасный способ передачи данных между параллельными потоками выполнения.

- **Как устроен канал и как он работает под капотом?**
Аллоцируются на куче. Сам по себе канал - это указатель на структуру: `qcount` - кол-во элементов в буфере, `dataqsize` - размерность буфера, `buf` - ссылка на буфер (кольцевая очередь), `closed` - флаг закрыт ли канал, `recvq` - указатель на связный список горутин, ожидающих чтения, `sendq` - указатель на связный список горутин, ожидающих записи, `recvx` - номер ячейки буфера для чтения, `sendx` - номер ячейки буфера для записи, `lock` - мьютекс. Обладает семантикой FIFO. Во время работы с каналом горутины могут изменять своё состояние (`running`, `waiting`, `runnable`) с помощью планировщика, для этого нужны две очереди `sendq` и `recvq`, там хранятся горутины, которые стоят на паузе.
В случае, когда есть спящий `sender`, его "разбудит" пришедшая горутина `reciever` после того, как освободит ячейку буфера для его данных, `sender` перейдёт в состояние `runnable`. 
В случае, когда есть спящий `reciever`, пришедший`sender` переместит данные из своего стека напрямую в стек спящей горутины-получателя, эта оптимизация позволяет избежать лишнего копирования данных, это в целом один из двух случаев рантайма Go, где одна горутина получает доступ к стеку другой горутины. Второй - это не буферезированные каналы, они кладут и берут данные напрямую из стеков друг друга.

- **Какие есть типы каналов в Golang?**
не буферизованные и буферизованные

- **Что если писать/читать в закрытый канал?**
Если вы пытаетесь записать значение в закрытый канал в Go, это вызовет панику (panic). Попытка отправить значение в закрытый канал считается ошибкой выполнения и приводит к аварийному завершению программы.

- **Чем отличается запись/чтение в буферизованном и небуферизованном канале?**
В случае с не буферизованным каналом запись блокирует отправляющую горутину до тех пор, пока другая горутина не выполнит чтение из канала. Чтение блокирует читающую горутину, пока другая не выполнит запись.
В случае с буферизованным каналом запись будет блокирующей только в случае, если буфер заполнен. Чтение блокирует читающую горутину только если буфер пуст. 

- **Что если закрыть закрытый канал?**
Попытка отправить данные в закрытый канал вызывает панику.

- **Какие операции есть с каналами?**
Создание канала (`make`). Отправка данных в канал (`ch <- value`). Получение данных из канала (`value := <-ch`). Закрытие канала (`close(ch)`). Выбор из нескольких каналов (`select`).


