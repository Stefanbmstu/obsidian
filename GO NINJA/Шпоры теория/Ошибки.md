

1. **Что такое интерфейс `error` в Go и как он используется?**
   - **Ответ:** Интерфейс `error` представляет собой тип с единственным методом `Error() string`. Любой тип, реализующий этот метод, может быть использован в качестве ошибки. Обычно ошибки создаются с помощью функции `errors.New("error message")` или пакета `fmt`.

   ```go
   package main

   import (
       "errors"
       "fmt"
   )

   func main() {
       err := errors.New("an error occurred")
       fmt.Println(err)
   }
   ```

2. **Что такое функция `errors.Is` и как она используется?**
   - **Ответ:** Функция `errors.Is` позволяет проверить, соответствует ли данная ошибка конкретной. Она рекурсивно разворачивает ошибки, если они обёрнуты.

   ```go
   package main

   import (
       "errors"
       "fmt"
   )

   var ErrNotFound = errors.New("not found")

   func find() error {
       return ErrNotFound
   }

   func main() {
       err := find()
       if errors.Is(err, ErrNotFound) {
           fmt.Println("Error is ErrNotFound")
       } else {
           fmt.Println("Unknown error")
       }
   }
   ```

3. **Как работает функция `errors.As` и когда её использовать?**
   - **Ответ:** Функция `errors.As` позволяет проверить, является ли ошибка или одна из её обёрток конкретным типом и, если да, присвоить её переменной.

   ```go
   package main

   import (
       "errors"
       "fmt"
   )

   type CustomError struct {
       Message string
   }

   func (e *CustomError) Error() string {
       return e.Message
   }

   func find() error {
       return &CustomError{Message: "custom error"}
   }

   func main() {
       err := find()
       var customErr *CustomError
       if errors.As(err, &customErr) {
           fmt.Println("Custom error occurred:", customErr.Message)
       } else {
           fmt.Println("Unknown error")
       }
   }
   ```

4. **Как создать кастомную ошибку и почему это может быть полезно?**
   - **Ответ:** Кастомные ошибки позволяют добавлять дополнительную информацию и контекст к ошибкам. Их можно создавать, реализуя метод `Error()` для структур.

   ```go
   package main

   import (
       "fmt"
   )

   type MyError struct {
       Code    int
       Message string
   }

   func (e *MyError) Error() string {
       return fmt.Sprintf("Error %d: %s", e.Code, e.Message)
   }

   func main() {
       err := &MyError{Code: 404, Message: "resource not found"}
       fmt.Println(err)
   }
   ```

5. **Что такое `defer`, `panic` и `recover` и как их использовать для обработки ошибок?**
   - **Ответ:** `defer` используется для отложенного выполнения функций, `panic` для создания паники (прерывания выполнения), а `recover` для восстановления из паники. Вместе они могут использоваться для обработки неожиданных ошибок.

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       defer func() {
           if r := recover(); r != nil {
               fmt.Println("Recovered from:", r)
           }
       }()
       fmt.Println("Before panic")
       panic("Something went wrong")
       fmt.Println("After panic")
   }
   ```

6. **Как использовать пакет `fmt` для создания форматированных ошибок?**
   - **Ответ:** Пакет `fmt` позволяет создавать форматированные строки, которые можно использовать в качестве сообщений об ошибках.

   ```go
   package main

   import (
       "fmt"
   )

   func main() {
       err := fmt.Errorf("an error occurred: %d", 404)
       fmt.Println(err)
   }
   ```

7. **Как оборачивать ошибки с дополнительным контекстом с помощью пакета `fmt` и функции `fmt.Errorf`?**
   - **Ответ:** С помощью функции `fmt.Errorf` и специального формата `%w` можно оборачивать ошибки, добавляя контекст.

   ```go
   package main

   import (
       "errors"
       "fmt"
   )

   var ErrNotFound = errors.New("not found")

   func find() error {
       return fmt.Errorf("find error: %w", ErrNotFound)
   }

   func main() {
       err := find()
       if errors.Is(err, ErrNotFound) {
           fmt.Println("Original error:", ErrNotFound)
           fmt.Println("Wrapped error:", err)
       }
   }
   ```


8. **Как в Go обычно обрабатываются ошибки?**
   Ответ: В Go ошибки обычно возвращаются как второе (или последнее) значение из функции и проверяются с помощью условного оператора.

9. **В чем разница между `panic` и `error` в Go?**
   Ответ: `error` - это значение, которое функция возвращает для обработки ошибок в штатном режиме. `panic` используется для неожиданных критических ошибок и останавливает выполнение программы.

10. **Объясните разницу между `errors.New()` и `fmt.Errorf()`.**
   Ответ: `errors.New()` создает простую ошибку с заданным текстом, а `fmt.Errorf()` позволяет форматировать текст ошибки с использованием спецификаторов формата.

11. **Как работает утверждение типа (type assertion) в Go и как оно связано с обработкой ошибок?**
   Пример:
   ```go
   val, ok := interface{}(123).(int)
   if !ok {
       fmt.Println("Преобразование не удалось")
   }
   ```

12. **Как создать и использовать пользовательский тип ошибки?**
   Пример:
   ```go
   type MyError struct {
       Msg string
   }

   func (e *MyError) Error() string {
       return e.Msg
   }
   ```

13. **Как реализовать цепочку ошибок в Go?**
   Ответ: Можно использовать пакет `github.com/pkg/errors` или встроенную функцию `fmt.Errorf()` с директивой `%w`.

14. **Какие преимущества дает использование интерфейса `error` вместо конкретных типов ошибок?**
   Ответ: Это обеспечивает гибкость и позволяет функциям возвращать различные типы ошибок, не меняя сигнатуру.

15. **Как правильно логировать ошибки в Go?**
   Ответ: Рекомендуется логировать ошибки только один раз, обычно на верхнем уровне обработки, и включать контекстную информацию.

