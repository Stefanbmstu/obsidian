- **Что такое индексы в базе данных, как и для чего их использовать и создавать?**
Это специальные структуры данных, которые позволяют ускорить операции поиска и выборки данных. 
Нужны для ускорения поиска, сортировки и ускорение операций JOIN.
Индексы создаются на один или несколько столбцов таблицы и хранятся в виде дерева (чаще всего `B-дерево` или его разновидности, но также могут быть `хэш-индексы`, `R-деревья`, `Bitmap-индексы`, `Full-Text Index`). Это позволяет значительно сократить количество операций чтения при поиске данных по индексу.
Чаще всего используется `B-дерево`, потому что так проще читать данные с диска (данные идёт друг за другом).
Сложность поиска сокращается с О(n) до ~O(logn)

Пример создания простого индекса:
```sql
CREATE INDEX index_name ON table_name(column_name);
```

Создание составного индекса:
```sql
CREATE INDEX index_name ON table_name(column1, column2);
```

Стандартное правило составления индекса: первыми указываются столбцы, которые проверяются на равенство (`=` или `!=`) последним указывается первый (или **селективный**) элемент на неравенство (`<` `>` `<=` `>=` а также `order by`).

- **Как использовать индексы в JOIN запросах?**
Индексы должны быть созданы на столбцах, участвующих в условиях соединения (`ON` или `USING`).

- **Что такое HAVING, что он делает как и зачем его использовать?**
**HAVING** — это оператор SQL, который используется для фильтрации записей после применения агрегатных функций. Он часто применяется в сочетании с оператором `GROUP BY`, чтобы ограничить результаты группировки.

- **Возможен ли JOIN со вложенными запросами, как?**
Да, возможен.

В этом примере подзапрос используется в части `FROM`, и результат подзапроса затем соединяется с другой таблицей. Предположим, у нас есть две таблицы: `orders` и `customers`. Мы хотим получить информацию о заказах и их клиентах, но сначала нужно отфильтровать заказы по некоторым условиям.

```sql
SELECT o.order_id, o.order_date, c.customer_name
FROM 
    (SELECT order_id, order_date, customer_id
     FROM orders
     WHERE order_date >= '2023-01-01') AS o
JOIN customers AS c ON o.customer_id = c.customer_id;
```

**Объяснение:**

1. **Подзапрос**: `(SELECT order_id, order_date, customer_id FROM orders WHERE order_date >= '2023-01-01') AS o` — выбирает заказы, сделанные с 1 января 2023 года и создает временную таблицу `o`.
2. **JOIN**: `JOIN customers AS c ON o.customer_id = c.customer_id` — соединяет эту временную таблицу с таблицей `customers` по полю `customer_id`.

- **Разница между WHERE и HAVING и можно ли использовать HAVING без группировки данных?**
Операторы `WHERE` и `HAVING` выполняют функции фильтрации в SQL, но они работают на разных этапах обработки запроса и имеют разные цели.

`WHERE` не может использовать агрегатные функции, фильтрует строки **до** выполнения группировки, используется для фильтрации записей на основе конкретных условий.

`HAVING` может использовать агрегатные функции, фильтрует группы строк **после** выполнения группировки и агрегатных функций, используется для фильтрации агрегированных данных.
Можно использовать `HAVING` без явной группировки, но это обычно не имеет большого смысла. Если запрос не содержит `GROUP BY`, то весь набор данных считается одной группой. Таким образом, `HAVING` будет применяться к этой единственной группе.

- **Что такое EXPLAIN?**
Это команда SQL, которая используется для получения информации о плане выполнения запроса. Она помогает понять, как база данных планирует выполнить запрос, какие индексы будут использованы, какие таблицы будут сканироваться и в каком порядке.

**Анализ производительности**: Помогает выявить узкие места в запросах и понять, почему они могут выполняться медленно.

**Оптимизация запросов**: Позволяет определить, какие индексы используются и какие не используются, что может привести к созданию новых индексов или изменению структуры запроса.

**Понимание плана выполнения**: Показывает, какие операции выполняются базой данных (например, полное сканирование таблицы, использование индексов, операции соединения и т.д.).

Пример кода:
```sql
EXPLAIN SELECT * FROM employees WHERE department_id = 1;
```

- **Что такое транзакции и блокировки?**
Это единицы работы, которые выполняются как одно целое и обладают несколькими ключевыми свойствами, называемыми **ACID**. Транзакции используются для обеспечения целостности (консистентности) данных и корректности операций в базах данных.

Синтаксис:
```sql
BEGIN TRANSACTION;

-- Снять деньги со счета отправителя
UPDATE accounts SET balance = balance - 100 WHERE account_id = 'sender_id';

-- Добавить деньги на счет получателя
UPDATE accounts SET balance = balance + 100 WHERE account_id = 'receiver_id';

-- Проверить, если обе операции успешны, зафиксировать транзакцию
COMMIT;

-- В случае ошибки, отменить транзакцию
ROLLBACK;
```

- **Что такое ACID?**
**Атомарность (Atomicity)**:
Атомарность означает, что все операции внутри транзакции выполняются как единое целое: либо все операции успешно завершаются, либо ни одна из них не выполняется. Если одна из операций не может быть выполнена, транзакция откатывается (roll back), и все изменения, сделанные в рамках этой транзакции, отменяются.

**Согласованность (Consistency)**:
Согласованность гарантирует, что транзакция переводит базу данных из одного консистентного состояния в другое. После выполнения транзакции все ограничения и правила целостности базы данных должны быть выполнены, и база данных должна оставаться в валидном состоянии.

**Изолированность (Isolation)**:
Изолированность гарантирует, что выполнение транзакции будет изолировано от других транзакций. Это означает, что изменения, внесенные одной транзакцией, не должны быть видны другим транзакциям до тех пор, пока первая транзакция не завершится успешно. Изолированность помогает избежать ситуаций, таких как потеря обновлений или чтение неполных данных.

**Долговечность (Durability)**:
Долговечность гарантирует, что изменения, сделанные транзакцией, сохраняются в базе данных даже в случае сбоя системы. После того как транзакция была подтверждена (committed), ее изменения становятся постоянными и не могут быть утеряны.

- **Что такое блокировки?**
Это механизм синхронизации, используемый для управления доступом к данным в базе данных, чтобы избежать конфликтов и обеспечить согласованность данных при одновременном доступе со стороны нескольких транзакций.

Основные типы: 

**Блокировка на уровне строки** - блокирует конкретную строку в таблице. Это наиболее избирательный тип блокировки, позволяющий минимизировать влияние на другие строки и транзакции.

**Блокировка на уровне страницы** - блокирует целую страницу данных, что может включать несколько строк. Это может снизить накладные расходы на блокировки по сравнению с блокировками на уровне строк, но может быть менее избирательным.

**Блокировка на уровне таблицы** - блокирует всю таблицу. Это может быть более простой подход, но может привести к более высокой конкуренции за ресурсы и снижению параллелизма.

**Совместная блокировка** - позволяет нескольким транзакциям читать данные, но не позволяет их изменять. Эти блокировки обеспечивают доступ для чтения, но предотвращают изменение данных до тех пор, пока блокировка не будет снята.

**Эксклюзивная блокировка** - позволяет одной транзакции изменять данные и предотвращает доступ к этим данным другим транзакциям. Этот тип блокировки гарантирует, что данные могут быть изменены только одной транзакцией за раз.

**Селективные блокировки** - в некоторых СУБД поддерживаются более сложные типы блокировок, такие как комбинированные блокировки или динамические блокировки, которые позволяют настраивать уровень изоляции в зависимости от типа операций.

- **Какие бывают уровни изоляции транзакций?**
**Read Uncommitted** (чтение неподтвержденных данных) - транзакции могут читать данные, которые были изменены другими транзакциями, даже если эти изменения еще не были подтверждены.

**Read Committed (чтение подтвержденных данных)** - транзакции могут читать только те данные, которые были подтверждены другими транзакциями. Неподтвержденные изменения других транзакций не видны.

**Repeatable Read (Повторяемое чтение)** - транзакция гарантирует, что все данные, которые она прочитала, останутся неизменными до завершения транзакции. Это предотвращает неповторяющиеся чтения.

**Serializable (Сериализуемый)** - самый высокий уровень изоляции. Транзакции выполняются так, как если бы они были выполнены последовательно, одна за другой. Это полностью предотвращает грязные чтения, неповторяющиеся чтения и фантомные чтения.

- **Read Uncommitted**: Подходит для приложений, где высокая производительность важнее абсолютной точности данных, и где грязные чтения могут быть приемлемыми.
- **Read Committed**: Обеспечивает лучшее управление консистентностью данных по сравнению с Read Uncommitted, предотвращая грязные чтения.
- **Repeatable Read**: Подходит для приложений, где важно, чтобы данные не изменялись во время выполнения транзакции, но фантомные чтения могут быть проблемой.
- **Serializable**: Обеспечивает наивысший уровень консистентности, идеально для критичных к точности данных приложений, но может приводить к снижению производительности.

Синтаксис:
```sql
-- Установка уровня изоляции на Read Uncommitted
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;

BEGIN TRANSACTION;
-- Выполнение операций
COMMIT;

-- Установка уровня изоляции на Serializable
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN TRANSACTION;
-- Выполнение операций
COMMIT;
```

- **Какие бывают аномалии?**
Аномалии баз данных возникают из-за параллельного выполнения транзакций и могут привести к некорректным или несогласованным данным. Уровни изоляции транзакций помогают управлять этими аномалиями, обеспечивая различный баланс между производительностью и консистентностью данных. Выбор уровня изоляции зависит от конкретных требований приложения и его потребностей в целостности данных.

**Грязное чтение (Dirty Read)** - грязное чтение происходит, когда одна транзакция читает данные, которые были изменены другой транзакцией, но эта вторая транзакция еще не была подтверждена. Если вторая транзакция отменяется, то первая транзакция останется с данными, которые на самом деле никогда не были завершены.

**Неповторяющееся чтение (Non-repeatable Read)** - неповторяющееся чтение происходит, когда транзакция читает данные, которые затем изменяются другой транзакцией до завершения первой транзакции. При повторном чтении данных в первой транзакции результат может отличаться.

**Фантомное чтение (Phantom Read)** - фантомное чтение происходит, когда транзакция выполняет запрос, а другая транзакция добавляет или удаляет строки, которые соответствуют условиям запроса первой транзакции. В результате при повторном выполнении того же запроса первая транзакция может увидеть новые строки или пропущенные строки, которые не были видны при первом выполнении запроса.

**Потеря обновления (Lost Update)** - потеря обновления происходит, когда изменения, внесенные одной транзакцией, перезаписываются другой транзакцией, и первое изменение теряется.

Разные уровни изоляции транзакций помогают минимизировать или устранить указанные аномалии:
- **Read Uncommitted**: Позволяет все типы аномалий, включая грязное чтение, неповторяющееся чтение и фантомные чтения.
- **Read Committed**: Предотвращает грязное чтение, но допускает неповторяющееся чтение и фантомные чтения.
- **Repeatable Read**: Предотвращает грязное чтение и неповторяющееся чтение, но может допускать фантомные чтения.
- **Serializable**: Устраняет все перечисленные аномалии, обеспечивая наиболее строгую изоляцию.