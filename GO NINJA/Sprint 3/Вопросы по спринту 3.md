### Race condition
**Что такое race condition?**
Race condition — это когда несколько горутин одновременно обращаются к общему ресурсу без синхронизации, и хотя бы одна пишет.  
В Go ищется флагом `-race`.  
Решается — атомиками, мьютексами или каналами (в зависимости от уровня гранулярности).
**Как обнаружить race condition?**
В Go есть race detector `go run -race main.go`
**Какие есть способы устранения race condition?**
Простые данные → atomic. Несколько чтений → RWMutex. Сложные потоки и координация → каналы.
**Что такое data race?**
Data race (состояние гонки данных) — это тип ошибки в многопоточном программировании, который возникает, когда несколько потоков или горутин одновременно читают и записывают одни и те же данные без надлежащей синхронизации.
**Что такое dead lock?**
Это ситуация в многопоточном программировании, когда два или более потока (или горутины) заблокированы навсегда, ожидая освобождения ресурсов, которые удерживаются друг другом. В результате этого ни один из потоков не может продолжить выполнение, и программа застревает.
### Планировщик
Планировщик Go — часть рантайма, реализующая M:N модель (GMP). Он распределяет горутины (G) по системным потокам (M) с помощью виртуальных процессоров (P).
**Как работает планировщик в Golang?**
Планировщик рантайма Go работает по GMP модели, где 
- G - это горутина (что исполняем), 
- M - machine (машинные треды, где исполняем) и 
- P - Processor (структура в коде планировщика, права и ресурсы для исполнения).
У P есть локальная очередь горутин, есть от дельный слот и свой тред. Также есть глобальная очередь (она защищена мьютексом, т.к. с ней работают все процессоры), некоторые треды, занимающиеся `sync syscall` (синхронными системными вызовами) и `netpoller`.

**Как работает вытесняющая многозадачность?**
Это метод управления задачами в ОС, при котором ОС управляет выполнением задач (процессов или потоков) и может приостанавливать выполнение одной задачи, чтобы дать время другим задачам. Это обеспечивает более равномерное распределение процессорного времени между задачами и помогает поддерживать отзывчивость системы.
**За счет чего достигается параллельное выполнение в Golang?** 
В Go (или Golang) параллельное выполнение достигается за счет использования **горутины** и **каналов**, а также встроенного планировщика задач в рантайме Go. Эти механизмы позволяют легко и эффективно управлять многопоточностью и параллелизмом.
**В чем разница между вытесняющим и кооперативным планировщиком?** 
Вытесняющий и кооперативный планировщики представляют разные подходы к многозадачности. 
Вытесняющий планировщик обеспечивает более автоматическое и гибкое управление задачами. 
Кооперативный планировщик проще в реализации, но требует от задач явного управления временем выполнения, что может привести к проблемам с блокировкой и отзывчивостью системы.
**Сколько потоков операционной системы мы можем создать?**
Около 10^4. В теории, операционные системы могут поддерживать создание миллионов потоков, но на практике ограничения зависят от доступных ресурсов и настроек системы. Важно учитывать потребление ресурсов и влияние на производительность при создании большого количества потоков.
**В планировщике до версии 1.15 какие операции приводят к переключению контекста горутин?**
В Go контекстное переключение горутин управляется встроенным планировщиком, и разработчики не имеют прямого контроля над этим процессом. Однако, есть способы косвенно повлиять на планирование и переключение контекста горутин.
`runtime.Gosched` позволяет текущей горутине передать управление планировщику, чтобы другие горутины могли получить процессорное время. Это полезно, когда вы хотите сделать паузу в выполнении текущей горутины, чтобы дать возможность другим горутинам работать.
### Горутины
**Что такое горутина?**
В Go горутина — легковесный поток, легкий контекст исполнения, который имеет свой стек и набор регистров, но планирование происходит не на уровне  ОС, а внутри самого рантайма Go. Копирования стека не будет.
**Чем горутина отличается от треда?**
Стек горутины динамический (~2 КБ → растёт), у треда — фиксированный (1–2 МБ).
Переключение горутин делается в user space, дешевле чем у тредов.
Блокировка горутины не блокирует поток — runtime перепланирует другие.
**В чем преимущества горутин над тредами?**
Ядро про горутины вообще не знает — ими управляет пользовательский планировщик Go. Достаточно изменить регистры, стек не нужно копировать.
**Что есть в Golang для многопоточности?**
Go не даёт «тредов», а строит высокоуровневую модель — горутины + каналы + sync/atomic/context.
**Какие есть способы связи между горутинами, какие плюсы и минусы?**
Каналы (chan) — безопасная передача данных без общей памяти.
✅ просто и идиоматично, ❌ медленнее, возможны дедлоки.
Общая память + sync.Mutex/RWMutex — общий доступ с блокировками.
✅ быстро, ❌ риск race и сложнее отладка.
sync/atomic — атомарные операции над простыми типами.
✅ максимально быстро, ❌ ограничено по применению.
### Примитивы синхронизации
**Какие примитивы синхронизации есть в Golang?**
Go даёт набор из sync, atomic и каналов (chan) — всё остальное строится на них.
Основные примитивы синхронизации в Go:
**`Mutex`** — взаимное исключение для критических секций (простой lock/unlock).
**`RWMutex`** — много читателей, один писатель; страдает от cache contention при большом числе читателей, потому что `RLock()` модифицирует общий счётчик.
**`WaitGroup`** — счётчик работ: `Add/Done/Wait` для ожидания набора горутин.
**`Cond`** — низкоуровневый примитив для сигналов ожидания; обычно заменяется каналами..
**`Once`** — однократная инициализация (ленивые синглтоны).
**`Pool`** — кеширование объектов для снижения аллокаций/GC; нет гарантий возврата.
**`Map`** — конкурентная мапа, оптимизирована для read-heavy: `read`+`dirty`, атомики для быстрых чтений, мьютекс для редких записей.
**sync/atomic** — атомарные операции на уровне CPU (CAS, Add, Load/Store) без блокировок и переключений контекста.

**Отличие мьютекса от семафора**
Мьютекс — только один владелец (lock/unlock).
Семафор — ограниченное число разрешений.
Мьютекс проще и безопаснее; семафор гибче, но требует аккуратного контроля счётчика.

**Чем мьютексы отличаются от атомиков?**
Мьютекс — это блокировка, позволяющая только одному потоку работать с ресурсом (остальные ждут).  
Атомик — это переменная, операции с которой выполняются атомарно без блокировок.  
Мьютекс — медленнее, но универсальнее; атомик — быстрее, но подходит только для простых данных.

**Какие примитивы синхронизации использовал в работе и для чего?**
`sync.Mutex` — защита разделяемых структур при записи.  
    _Пример:_ защищал кэш/мапу при обновлениях.
`sync.RWMutex` — когда много чтений и мало записей.  
    _Пример:_ справочник настроек: `RLock` для чтения, `Lock` для редких апдейтов.
Каналы (`chan`) + `select` — координация горутин и передача данных без явных блокировок.  
    _Пример:_ фан-ина/фан-аут, воркеры, сигнал остановки.
`context.Context` — кооперативная отмена и дедлайны между горутинами.  
    _Пример:_ останавливал воркеры по `ctx.Done()`.
`sync.WaitGroup` — дождаться завершения набора горутин.  
    _Пример:_ запускал N воркеров и делал `wg.Wait()`.
`sync.Cond` — ожидание события при условии.  
    _Пример:_ продюсер/консюмер над общим буфером.
`sync.Once` — ленивые одноразовые инициализации.  
    _Пример:_ создание синглтона/кэша.
`sync/atomic` — счётчики/флаги без мьютексов.  
    _Пример:_ атомарный инкремент метрик, CAS для state.
Семафоры — лимит параллелизма.  
    _Пример:_ `x/sync/semaphore.Weighted` для ограничения одновременных задач/IO.

**Как устроена WaitGroup под капотом и как ее можно реализовать самому?**
По сути, `WaitGroup` — это счётчик с внутренним семафором; блокируется, пока счётчик не обнулится.
Внутри — один 64-битный `state` и семафор:
- **верхние 32 бита**: счётчик активных работ (`counter`);
- **нижние 32 бита**: число ожидающих `Wait()` (`waiters`);
- **sema**: примитив для усыпления/пробуждения ожидающих.
`Add(n)` атомарно меняет `counter`.  
	Если `counter` стал **0**, пробуждает всех `waiters`. Если ушёл **< 0** — `panic`.
`Wait()` атомарно увеличивает `waiters` и, если `counter > 0`, блокируется на семафоре. `Done()` — это `Add(-1)`.

**Правила использования:** `Add` нельзя вызывать конкурентно с активным `Wait()` (добавляйте до старта горутин). После того как счётчик вернулся к нулю, группу можно переиспользовать.

```go
type MyWG struct {
    mu   sync.Mutex
    cond *sync.Cond
    cnt  int
}

func NewMyWG() *MyWG {
    wg := &MyWG{}
    wg.cond = sync.NewCond(&wg.mu)
    return wg
}

func (w *MyWG) Add(n int) {
    w.mu.Lock()
    w.cnt += n
    if w.cnt < 0 {
        w.mu.Unlock()
        panic("MyWG: negative counter")
    }
    if w.cnt == 0 {
        // Разбудить всех ожидающих
        w.cond.Broadcast()
    }
    w.mu.Unlock()
}

func (w *MyWG) Done() { w.Add(-1) }

func (w *MyWG) Wait() {
    w.mu.Lock()
    for w.cnt != 0 {
        w.cond.Wait()
    }
    w.mu.Unlock()
}
```
**Расскажи про sync.Map**
`sync.Map` оптимизирован под сценарии “много чтений — мало записей”.  
Использует две мапы: `read` (lock-free, атомарный указатель) и `dirty` (под `Mutex`).  
Чтение — быстрая атомарная загрузка из `read`, промахи и записи — через `dirty`.  
Это снижает cache contention, потому что чтения не трогают общие кеш-линии, в отличие от `RWMutex`.
При переполнении `dirty` делается promotion — копия становится новым `read`, старая сбрасывается.

сначала смотрим в чистую, если не нашли, смотрим в грязную
удаление - присовение указателю нил

Cache contention — конфликт кешей, когда несколько ядер работают с одной кеш-линией (обычно 64 байта).  
Даже независимые переменные внутри линии вызывают **false sharing** — записи одного ядра инвалидируют кеши других.  
В `RWMutex` это происходит из-за общего счётчика читателей; в `sync.Map` — нет, потому что чтения атомарны и не пишут в память.

**Расскажи про пакет sync**
Пакет `sync` предоставляет базовые примитивы синхронизации — `Mutex`, `RWMutex`, `WaitGroup`, `Cond`, `Once`, `Pool`, `Map`.  
Все они работают на блокировках и атомиках, обеспечивая безопасный доступ к данным между горутинами.  
Нулевые значения готовы к использованию; копировать после использования нельзя.
**`Mutex`** — взаимное исключение для критических секций (простой lock/unlock).
**`RWMutex`** — много читателей, один писатель; страдает от cache contention при большом числе читателей, потому что `RLock()` модифицирует общий счётчик.
**`WaitGroup`** — счётчик работ: `Add/Done/Wait` для ожидания набора горутин.
**`Cond`** — низкоуровневый примитив для сигналов ожидания; обычно заменяется каналами.
**`Once`** — однократная инициализация (ленивые синглтоны).
**`Pool`** — кеширование объектов для снижения аллокаций/GC; нет гарантий возврата.
**`Map`** — конкурентная мапа, оптимизирована для read-heavy: `read`+`dirty`, атомики для быстрых чтений, мьютекс для редких записей.

**Есть общий ресурс. Хотим, чтобы к нему одновременно обращались только N горутин. Как это сделать?**
используем **семафор**
Семафор — это примитив для ограничения числа одновременно выполняющихся горутин.  
В Go можно сделать через буферизированный канал или пакет `x/sync/semaphore`.
Вариант 1: буферизированный канал как семафор (встроенное)
```go
sem := make(chan struct{}, N)

func useResource() {
    sem <- struct{}{}       // acquire
    defer func(){ <-sem }() // release

    // доступ к общему ресурсу
}
```
Вариант 2: взвешенный семафор из `golang.org/x/sync/semaphore`
```go
var sem = semaphore.NewWeighted(int64(N))

func useResource(ctx context.Context) error {
    if err := sem.Acquire(ctx, 1); err != nil { return err }
    defer sem.Release(1)
    // работа с ресурсом
    return nil
}
```
Оба ограничивают одновременный доступ к ресурсу максимум **N** горутинами; второй удобнее с отменой по `context`.