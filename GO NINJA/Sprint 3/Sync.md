**`Mutex`** — взаимное исключение для критических секций (простой lock/unlock).
**`RWMutex`** — много читателей, один писатель; но при большом числе читателей может хуже масштабироваться из-за cache contention.
**`WaitGroup`** — счётчик работ: `Add/Done/Wait` для ожидания набора горутин.
**`Cond`** — ожидание события по условию поверх `Mutex` (producer/consumer).
**`Once`** — однократная инициализация (ленивые синглтоны).
**`Pool`** — кеширование объектов для снижения аллокаций/GC; нет гарантий возврата.
**`Map`** — конкурентная мапа, оптимизирована для read-heavy: `read`+`dirty`, атомики для быстрых чтений, мьютекс для редких записей.

Важно:
- Нулевые значения примитивов `sync` — рабочие; копировать после использования **нельзя**.
- Для атомарных операций над числами/указателями — пакет **`sync/atomic`** (отдельно от `sync`).
### sync.WaitGroup
применяется для ожидания завершения множества горутин и позволяет избежать использования таймеров с неопределенным временем ожидания. Важно правильно увеличивать и уменьшать счетчик, а также передавать WaitGroup по указателю, чтобы избежать копирования.
создание горутины не есть её запуск сразу
wg.Done() через defer
```go
var wg sync.WaitGroup
wf.add(5)

for i := 0, i < 5; i++ {
	// wg.Add(1)
	go func() {
		defer wg.Done()
		fmt.Println("test)
	}()
}
wg.Wait()
```
контр интуитивные операции приводят к панике
wg.Wait() ждет пока счетчик будет 0, в другие функции предавать указатель
### sync.Mutex

взаимное исключение - может зайти только 1 горутина
Инкремент:
1. загрузка в локальное место (регистр)
2. операция (плюс)
3. возврат значения
Планировщик ОС может произойти вытеснение или прерывание
```go
func main {
	wg := sync.WaitGroup
	mutex := sync.Mutex
	wf.add(1000)
	
	value := 0
	for i := 0, i < 1000; i++ {
		go func() {
			defer wg.Done()
			mutex.Lock()
			value++
			mutex.Unlock()
		}()
	}
	wg.Wait()
	
	fmt.Println(value)
}
```
Горутина захватывает мьютекс и входит в критическую секцию, другая при попытке захвата перейдет в `waiting`, критические секции не перескеаются, что исключает вытеснение.
**Мьютекс в очереди**
```go
func main {
	var mutex sync.Mutex
	mutex.Lock()
	
	go func() {
		fmt.Println("Hi")
		mutex.Unlock()
	}()
	mutex.Lock()
	fmt.Println("Bye")
}
```
обеспечивает взаимное исключение, позволяя в один момент времени исполняться только одной горутине в критической секции. Особенности работы Mutex: блокировка, разблокировка, trylock, правильное использование defer для освобождения блокировки, а также проблемы с активным ожиданием и способы их оптимизации.

**Spinlock** — это примитив синхронизации, где поток в цикле (“крутится”, _spins_) и пытается захватить ресурс с помощью **CAS**. В отличие от Mutex, поток не засыпает, а постоянно проверяет флаг.
**Try-lock** — это вариант, где мы делаем одну попытку захвата блокировки и сразу возвращаем результат (успех/неудача), не блокируясь. CAS один раз.
### sync.Cond
Условная переменная - примитив синхронизации, обеспечивающий блокирование одного или нескольких потоков до момента наступления сигнала от другого потока о выполнении некоторого условия.
позволяет горутинам блокироваться до наступления определенного условия, реализуя сигналы wake и broadcast, с разъяснением отличий от каналов.
Рекомендуется ждать в цикле и проверять истинность
```go
func subscribe(name string, data map[string]string, c *sync.Cond) {
	c.L.Lock()

	for len(data) == 0 {
		c.Wait()
	}

	log.Printf("[%s] %s\n", name, data["key"])

	c.L.Unlock()
}

func publish(name string, data map[string]string, c *sync.Cond) {
	time.Sleep(time.Second)

	c.L.Lock()
	data["key"] = "value"
	c.L.Unlock()

	log.Printf("[%s] data publisher\n", name)
	c.Broadcast()
}

func main() {
	data := map[string]string{}
	cond := sync.NewCond(&sync.Mutex{})

	wg := sync.WaitGroup{}
	wg.Add(3)

	go func() {
		defer wg.Done()
		subscribe("subscriber_1", data, cond)
	}()

	go func() {
		defer wg.Done()
		subscribe("subscriber_2", data, cond)
	}()

	go func() {
		defer wg.Done()
		publish("publisher", data, cond)
	}()

	wg.Wait()
}
```
**Семафор** - примитив синхронизации, который используется для управления доступом к общим ресурсам несколькими потоками(горутинами).
Разница - мьютекс обеспечивает взаимоисключение в рамках одной горутины, а семафор может пропустить n горутин.
Семафор применяется для ограничения количества одновременно работающих горутин, реализуется через Condition Variable или каналы.
### sync.Pool
переменные хранятся в пулле и могут переиспользовать (но могут быть собраны сборщиком мусора).
помогает повторно использовать объекты для уменьшения нагрузки на сборщик мусора и аллокацию памяти.
### sync.Atomic
атомики - определенные значения в памяти, которые буду шариться между ядрами   
обеспечивают неделимость операций над данными и позволяют эффективно синхронизировать доступ к переменным без тяжелых блокировок. Рассматриваются функции add, load, store, swap, compare-and-swap (CAS) и их применение.
`atomic.CompareAndSwap(true, false)`
atomic.Pointer
### sync.RWMutex
позволяет множеству горутин одновременно читать данные, но ограничивает доступ к записи одним писателем, что повышает производительность при доминировании операций чтения.
Однако в некоторых случаях он может ухудшить производительность из-за сложностей с управлением блокировками и возможного голодания писателей. Выбор между Mutex и RWMutex должен базироваться на бенчмарках и характере нагрузки.
### sync.Map
синхронизированная мапа, оптимизированная для сценариев с большим количеством чтений и умеренным количеством записей. Использует две внутренние мапы (read и dirty), атомарные операции и мьютексы для оптимизации доступа.
read никогда не будет переиндексована (с использованием атомиков), грязная с использованием мьютекса
сначала смотрим в чистую, если не нашли, смотрим в грязную
удаление - присовение указателю нил
RWMutex с мапой порождают конфликты в кеше при чтении и записи в одной кеш-линии

Часто встречающиеся ошибки: локальные мьютексы вместо общих, неправильное использование defer, неадекватная гранулярность блокировок, рекурсивные блокировки, неправильный порядок захвата мьютексов, deadlock,ivelock — когда потоки активно мешают друг другу; starvation — когда некоторые потоки надолго остаются без ресурсов; data race — несинхронизированный доступ к общим данным. .
Инструменты отладки и предотвращения ошибок: race-детектор, правильное проектирование API, инкапсуляция примитивов синхронизации, использование бенчмарков и профилирование.
Go runtime умеет детектировать deadlock, но только если все горутины заблокированы и нет ни одной активной. В противном случае deadlock может остаться незамеченным. 