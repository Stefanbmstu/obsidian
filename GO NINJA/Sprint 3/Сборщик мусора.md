### **1. Что такое мусор**

- **Мусор** — объекты в памяти, на которые нет достижимых ссылок из программы.
    
- Пример: локальные переменные после выхода из функции.
    
- Если объект можно хранить **на стеке**, GC не нужен — стек просто перезапишется.
    
- Если объект “убегает” (escape) за пределы функции → он попадает в **кучу** (_heap_), где за ним следит GC.
### **2. Когда объект попадает в кучу**

- Решает **escape-анализ** компилятора:
    
    - Локальная переменная, на которую возвращается указатель — в кучу.
        
    - Стек подходит только для данных, чётко живущих в пределах функции.
        
    
- Куча требует GC, стек — нет.
### **3. Алгоритм GC в Go — Mark & Sweep**

#### **Mark (разметка)**

- Все объекты делятся на:
    
    - **Чёрные** — живые (нельзя удалять).
        
    - **Серые** — в очереди на обработку.
        
    - **Белые** — кандидаты на удаление.
        
    
- Начало: **GC Roots** (глобальные переменные, стеки горутин) → серые.
    
- Обработка: берём серый → красим в чёрный → его потомков в серый.
    
- В конце: чёрные — живые, белые — мусор.
    
#### **Sweep (очистка)**

- Обход кучи, освобождение белых объектов.
    
- Память помечается свободной; излишки могут вернуться ОС через **scavenger**.
    
- Меньше по затратам, чем Mark.
### **4. Параллельная работа и Write-barrier**

- Проблема: во время параллельной разметки может появиться ссылка от чёрного объекта на белый → белый удалят ошибочно.
    
- Решение:
    
    - **STW (Stop The World)** перед стартом, чтобы включить **write-barrier**.
        
    - _Write-barrier_ при изменении ссылок гарантирует, что новые объекты будут размечены корректно (новые → серые, новые созданные → чёрные).
        
    
- После этого разметка идёт параллельно с горутинами.
    
- Если аллокации идут быстрее, чем GC успевает размечать → **mark assist** (горутины помогают GC).
### **5. Жизненный цикл GC**

1. **STW** → включение write-barrier.
    
2. Параллельная разметка (mark).
    
3. **STW** → завершение разметки (mark termination).
    
4. Параллельная очистка (sweep) + scavenger.
    
5. Обычная работа программы.
    
### **6. Когда запускается GC**

1. Ручной вызов: runtime.GC().
    
2. Прошло ~2 минуты с последнего запуска.
    
3. Превышен порог памяти:
    

```
Порог = (Живая память прошлого цикла + GC Roots) × (1 + GOGC/100)
```
GOGC по умолчанию = 100.
определяет, **на сколько процентов должен вырасти размер живой памяти в куче, прежде чем Go запустит следующий цикл GC**.  
- ↑ GOGC → реже GC, ↑ память, ↓ общее время GC.
- ↓ GOGC → чаще GC, ↓ память, ↑ нагрузка GC.
4. Можно ограничить память: GOMEMLIMIT.
### **7. Ключевые нюансы**

- GC в Go **параллельный, трицветный, с write-barrier**.
    
- Производительность зависит от **размера живых объектов**, а не мусора.
    
- **Mark** — самая тяжёлая фаза (до 25% CPU).
    
- Sweep — дешёвый и идёт в фоне.
    
- Настройка GOGC — баланс между частотой GC и потреблением памяти.
    
- Escape-анализ напрямую влияет на нагрузку GC.

![[Pasted image 20250810115216.png]]