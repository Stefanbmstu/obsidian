Сборщик в Go является трассирующим, то есть вместо подсчета ссылок он ищет живые объекты.
Самый примитивный сценарий работы:
1. Останавливаются все потоки;
2. Без синхронизации обходится граф ссылок;
Начнем обход графа со стеков потоков и глобальных переменных, где есть указателя на кучу. Поиском в глубину проще парраллелить работу между потоками. Также у нас есть root set, то есть волна обхода, в рамках этой волны мы берем значение из очереди и даем потоку на обход в глубину. 
3. Помечаются все используемые объекты;
- **Чёрный** — исследованный (объект посещен и все ссылки из него исследованы) .
- **Серый** — ожидающий исследования (не по всем ссылкам от него прошлись).
- **Белые** — неисследованный.
Почему серый? В графе могут быть циклы, поэтому чтобы не зациклиться на вершинах и по кругу постоянно не ходить
4. Непомеченные объекты удаляются.

**Concurrent GC**
Можно запустить поток GC одновременно, который выполняет сбор мусора вместе с мутаторами
**Parallel GC**
Сборка мусора со STW, но потоки для сборки мусора работают параллельно. 

**Write barier**
В конкурентном выполнении мутаторы могут менять ссылки в рантайме, из-за чего объекты могут потеряться (новый родительский узел уже помечен в черный)
Барьер записи - если объект черный и он начинает ссылаться на новый объект, то покрасим указатель на новый объект сразу в серый цвет (серые добавляются в очередь на обход)
**Delete barier** 
Покрасим в серый объект, на который теряется ссылка. Но объект может дожить до следующей стадии сборки мусора.

Для включения/выключения брьеров делается короткий STW.
Что делать если очередь серых объектов не будет заканчиваться никогда? (ввиду множ аллокаций)
Нужно создавать объекты сразу черного цвета, иначе объекты могут не закончиться никогда.

**GO GC** выполняется конкурентно с основной программой с использованием барьеров записи. 

Фракция CPU, потребляемая воркерами GC, жестко зафиксирована на уровне 25%. Если GC понимает, что не справляется с потоком мусора, он может слегка притормозить новые аллокации, заставляя горутины тратить часть времени на сборку мусора (Mark Assist, позволяет довести фракцию до 30% )

**Мусор** — объекты в памяти, на которые нет достижимых ссылок из программы, локальные переменные после выхода из функции.
Если объект можно хранить **на стеке**, GC не нужен — стек просто перезапишется.
Если объект “убегает” (escape) за пределы функции → он попадает в **кучу** (_heap_), где за ним следит GC.

**Жизненный цикл GC**. 

1. Sweep termination (предыдущая чистка могла не закончиться)
- STW
- завершение всех sweep фаз
- удаление остатков мусора
2. Mark (параллельная разметка)
- write-barrier
- start the world
- сканирование глобальных переменных и стеков (при скане стеков горутины приостанавливаются)
3. Mark termination
- **STW** → завершение разметки
4. Sweep (параллельная чистка)
- отключаем write-barrier
- start the world
- очищаем ресурсы в фоне

**Когда запускается GC**. 

1. Ручной вызов: runtime.GC() - если сделать вызов, когда уже запущен, после фазы sweep он запустится заново.
2. Прошло ~2 минуты без GC - если мы ничего не аллоцировали за это время, все равно запустится (за это отвечает sysmon) .
3. Превышение динамического лимита кучи, установленного с помощью переменной GOGC. 
![[Pasted image 20251004201312.png]]
```
Порог = (Живая память прошлого цикла + GC Roots) × (1 + GOGC/100)
```
GOGC по умолчанию = 100.
определяет, **на сколько процентов должен вырасти размер живой памяти в куче, прежде чем Go запустит следующий цикл GC**.  
- ↑ GOGC → реже GC, ↑ память, ↓ общее время GC.
- ↓ GOGC → чаще GC, ↓ память, ↑ нагрузка GC.

**Допустим после крайней чистки осталось больше половины доступной памяти, а GC не успеет сработать в следующий раз, процесс будет убит OOM killer'ом**
Нужно освобождать больше памяти, то есть чаще запускать GC, но ручной подбор GOGC под сервис не самое веселое занятие.  
Может произойти спираль смерти
![[Pasted image 20251004202216.png]]
 В связи с этим появился новый параметр GOMEMLIMIT. Учитывая всю память, потребляемую приложением (не только кучу) и ориентируясь на заданную верхнюю границу потребления памяти, рантайм будет чаще вызывать сборку мусора и более агрессивно возвращать память ОС.
 Чтобы избежать скатывания GC в спираль смерти, для GOMEMLIMIT вводится искусственное ограничение на фракцию CPU - оно не превысит 50% даже в самых жестких ситуациях, когда мусора очень много, а память почти исчерпана. В этом случае приложение сможет аллоцировать новую память и может преодолеть лимит, поэтому GOMEMLIMIT является мягким барьером. 

![[Pasted image 20250810115216.png]]